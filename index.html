<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Generic RPG Tracker</title>

    <style>
      :root {
        --bg: #0b0f14;
        --text: #e9eef5;
        --muted: #97a6b8;
        --border: #223041;
        --btn: rgba(26, 39, 53, 0.9);
        --btnHover: rgba(34, 52, 71, 0.95);
        --danger: #ff6b6b;
        --ok: #7ce6a5;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
      }

      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 22px 16px 56px;
      }

      .header h1 {
        margin: 0 0 6px;
        font-size: 28px;
        letter-spacing: 0.2px;
      }

      .sub { margin: 0; color: var(--muted); }

      .card {
        margin-top: 14px;
        padding: 14px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(18, 26, 35, 0.88);
        backdrop-filter: blur(2px);
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 280px;
        gap: 12px;
        align-items: center;
      }

      .label { color: var(--muted); font-size: 14px; }

      input[type="number"], input[type="text"], input[type="url"] {
        width: 100%;
        padding: 10px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(15, 22, 32, 0.95);
        color: var(--text);
        outline: none;
      }

      select {
        width: 100%;
        padding: 10px 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(15, 22, 32, 0.95);
        color: var(--text);
        outline: none;
      }

      .topStats {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .topStats { grid-template-columns: 1fr 1fr 1fr; }
      }

      .statBox {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
      }
      .statLabel { font-size: 12px; color: var(--muted); display: flex; align-items: center; gap: 8px; }
      .statValue { margin-top: 4px; font-size: 18px; font-weight: 650; }

      .controls {
        margin-top: 12px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .btn {
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--btn);
        color: var(--text);
        cursor: pointer;
        user-select: none;
      }
      .btn:hover { background: var(--btnHover); }
      .btn:disabled { opacity: 0.45; cursor: not-allowed; }

      .qBtn {
        width: 40px;
        height: 40px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(0,0,0,0.12);
        color: var(--text);
        cursor: pointer;
        font-weight: 800;
      }
      .qBtn:hover { background: rgba(255,255,255,0.06); }

      .statusBar {
        margin-top: 10px;
        min-height: 18px;
        font-size: 13px;
        color: var(--muted);
        white-space: pre-wrap;
      }
      .statusBar.ok { color: var(--ok); }
      .statusBar.error { color: var(--danger); }

      .sectionTitle {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 12px;
      }
      .sectionTitle h2 { margin: 0; font-size: 18px; }

      .divider { height: 1px; background: var(--border); margin: 12px 0; opacity: 0.8; }
      .pill { padding: 6px 10px; border: 1px solid var(--border); border-radius: 999px; color: var(--muted); font-size: 12px; display:flex; gap:8px; align-items:center; }

      /* Class blocks */
      .classBlockWrap {
        margin-top: 10px;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(0,0,0,0.18);
        display: grid;
        gap: 10px;
      }
      .classBlockRow {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .classBlockRow { grid-template-columns: 1fr 160px 220px; align-items: end; }
      }
      .classBlockTitle {
        color: var(--muted);
        font-size: 13px;
        margin-bottom: 6px;
      }

      /* Action Economy */
      .economyWrap {
        margin-top: 12px;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .econRow {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .econRow { grid-template-columns: 210px 1fr; align-items: center; }
      }

      .econLeft {
        display: flex;
        align-items: center;
        gap: 10px;
        color: var(--muted);
        font-size: 13px;
      }

      .econIcon {
        width: 44px;
        height: 44px;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(0,0,0,0.25);
        display: grid;
        place-items: center;
        flex: 0 0 auto;
      }
      .econIcon img {
        width: 44px;
        height: 44px;
        object-fit: cover;
        display: block;
      }

      .econBtns {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      /* Health + AC */
      .hpGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .hpGrid { grid-template-columns: 1fr 1fr 1fr 1fr; }
      }

      .hpControls {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .hpControls { grid-template-columns: 1fr 1fr 1fr auto; align-items: end; }
      }

      /* Abilities */
      .abilityGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .abilityGrid { grid-template-columns: 1fr 1fr; }
      }

      .abilityCard {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: 56px 1fr auto;
        gap: 12px;
        align-items: center;
        position: relative;
        overflow: hidden;
      }

      .abilityActIcon {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 26px;
        height: 26px;
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(0,0,0,0.25);
      }
      .abilityActIcon img {
        width: 26px;
        height: 26px;
        object-fit: cover;
        display: block;
      }

      .abilityIcon {
        width: 56px;
        height: 56px;
        border-radius: 14px;
        overflow: hidden;
        background: rgba(0,0,0,0.25);
        border: 1px solid rgba(255,255,255,0.06);
        display: grid;
        place-items: center;
      }
      .abilityIcon img {
        width: 56px;
        height: 56px;
        object-fit: cover;
        display: block;
      }

      .missingIcon {
        font-size: 11px;
        color: var(--muted);
        padding: 6px;
        text-align: center;
        line-height: 1.2;
      }

      .abilityName { font-weight: 700; letter-spacing: 0.2px; }
      .abilityMeta { margin-top: 4px; font-size: 13px; color: var(--muted); }
      .abilityBtns { display: flex; gap: 8px; align-items: center; }

      /* Spell slots UI */
      .slotRow {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: 170px 1fr;
        gap: 10px;
        align-items: center;
        margin-top: 10px;
      }

      .slotLabel { color: var(--muted); font-size: 13px; }

      .slotBubbles {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .slotBubble {
        width: 42px;
        height: 42px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(26, 39, 53, 0.85);
        color: var(--text);
        cursor: pointer;
        font-weight: 800;
        user-select: none;
      }

      .slotBubble.used {
        opacity: 0.35;
        text-decoration: line-through;
      }

      /* Small spell blocks */
      .spellGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }
      @media (min-width: 900px) {
        .spellGrid { grid-template-columns: 1fr 1fr; }
      }

      .spellCard {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px;
        background: rgba(0,0,0,0.16);
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
      }

      .spellName { font-weight: 750; }
      .spellMeta { margin-top: 4px; font-size: 12px; color: var(--muted); }
      .spellBtns { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

      dialog {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 0;
        background: rgba(15, 22, 32, 0.98);
        color: var(--text);
        max-width: 900px;
        width: calc(100% - 24px);
      }
      dialog::backdrop { background: rgba(0,0,0,0.65); }

      .dlgHead {
        padding: 14px 14px 10px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
      }
      .dlgTitle { margin: 0; font-size: 18px; }

      .dlgBody { padding: 14px; }
      .dlgBody p { margin: 0 0 10px; line-height: 1.5; white-space: pre-wrap; }
      .dlgMeta { margin-top: 8px; color: var(--muted); font-size: 13px; }

      .dlgActions {
        padding: 12px 14px 14px;
        border-top: 1px solid var(--border);
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }

      .popupGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .popupGrid { grid-template-columns: 1fr 1fr; }
      }

      .popupSection {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
      }
      .popupSectionTitle {
        margin: 0 0 10px;
        font-size: 14px;
        color: var(--muted);
      }

      .popupBtns { display: flex; gap: 10px; flex-wrap: wrap; }

      /* Calculator popup */
      .calcDisplayBox {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(15, 22, 32, 0.95);
      }
      .calcExpr {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 14px;
        color: var(--muted);
        min-height: 18px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .calcResult {
        margin-top: 6px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 22px;
        font-weight: 800;
        color: var(--text);
        white-space: pre-wrap;
        word-break: break-word;
      }
      .calcGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: repeat(4, minmax(56px, 1fr));
        gap: 10px;
      }
      .calcKey {
        padding: 14px 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(26, 39, 53, 0.85);
        color: var(--text);
        cursor: pointer;
        font-weight: 750;
        text-align: center;
        user-select: none;
      }
      .calcKey:hover { background: var(--btnHover); }
      .calcKey.wide { grid-column: span 2; }
      .calcKey.danger { color: #fff; background: rgba(255, 107, 107, 0.25); }
      .calcKey.ok { color: #06120b; background: rgba(124, 230, 165, 0.95); border-color: rgba(124, 230, 165, 0.35); }
      .calcKey.ok:hover { filter: brightness(0.95); }

      .footer { margin-top: 16px; font-size: 13px; color: var(--muted); }
    </style>
  </head>

  <body>
    <main class="wrap">
      <header class="header">
        <h1>Generic RPG Tracker</h1>
        <p class="sub">Spellcasting: ./data/spellcasting.json, Spells: ./data/spells.json</p>
      </header>

      <section class="card" id="coreCard" aria-label="Core">
        <div class="row">
          <label for="levelInput" class="label">Character Level (1 to 20)</label>
          <input id="levelInput" type="number" min="1" max="20" step="1" />
        </div>

        <div class="row" style="margin-top: 10px;">
          <label for="multiclassToggle" class="label">Multiclass</label>
          <div class="controls" style="margin-top:0; justify-content:flex-end;">
            <label class="pill"><input id="multiclassToggle" type="checkbox" /> Enable (2 classes max, pooled slots)</label>
          </div>
        </div>

        <div class="classBlockWrap" aria-label="Class selection">
          <div class="classBlockTitle">Class Spellcasting</div>
          <div id="classBlocks"></div>
          <div class="sub" id="classWarning"></div>
        </div>

        <div class="divider"></div>

        <div class="row">
          <label for="buildManifestUrl" class="label">Build Manifest URL (optional)</label>
          <input id="buildManifestUrl" type="url" placeholder="./data/builds/paladin_base.json (example)" />
        </div>
        <div class="controls" style="margin-top: 10px;">
          <button id="loadManifest" class="btn" type="button">Load Manifest</button>
          <button id="addPackage" class="btn" type="button">Add Package URL</button>
          <button id="clearPackages" class="btn" type="button">Clear Packages</button>
          <div class="sub" id="packageSummary" style="margin-left:auto;"></div>
        </div>

        <div class="topStats">
          <div class="statBox">
            <div class="statLabel" id="statALabel">Resource A</div>
            <div class="statValue" id="statAText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel" id="statBLabel">Resource B</div>
            <div class="statValue" id="statBText">-</div>
          </div>
          <div class="statBox">
            <div class="statLabel" id="statCLabel">Resource C</div>
            <div class="statValue" id="statCText">-</div>
          </div>
        </div>

        <div class="controls">
          <button id="shortRest" class="btn" type="button">Short Rest</button>
          <button id="longRest" class="btn" type="button">Long Rest</button>
          <button id="nextTurn" class="btn" type="button">Next Turn</button>
          <button id="openCalcTop" class="btn" type="button">Open Calculator</button>
          <button id="openSpellbookTop" class="btn" type="button">Open Spellbook</button>
        </div>

        <div class="card" style="margin-top: 12px;">
          <div class="sectionTitle">
            <h2>Spell Slots</h2>
            <div class="sub" id="spellMetaText"></div>
          </div>

          <div id="spellSlotsWrap"></div>

          <div class="controls" style="margin-top: 12px;">
            <button id="spellsResetSlots" class="btn" type="button">Reset Slots</button>
            <button id="openSpellbookSlots" class="btn" type="button">Open Spellbook</button>
          </div>

          <div id="spellStatus" class="statusBar" role="status" aria-live="polite"></div>
        </div>

        <div class="economyWrap" aria-label="Action economy">
          <div class="econRow">
            <div class="econLeft">
              <div class="econIcon"><img id="iconAction" alt="Action" /></div>
              <div>Action</div>
            </div>
            <div class="econBtns">
              <button id="basicAttack" class="btn" type="button">Basic Attack</button>
              <button id="actionOptions" class="btn" type="button">Additional Options</button>
            </div>
          </div>

          <div class="econRow">
            <div class="econLeft">
              <div class="econIcon"><img id="iconBonus" alt="Bonus action" /></div>
              <div>Bonus Action</div>
            </div>
            <div class="econBtns">
              <button id="offhandAttack" class="btn" type="button">Offhand Attack</button>
              <button id="bonusOptions" class="btn" type="button">Additional Options</button>
            </div>
          </div>

          <div class="econRow">
            <div class="econLeft">
              <div class="econIcon"><img id="iconReaction" alt="Reaction" /></div>
              <div>Reaction</div>
            </div>
            <div class="econBtns">
              <button id="oppAttack" class="btn" type="button">Attack of Opportunity</button>
              <button id="readiedAttack" class="btn" type="button">Readied Attack</button>
              <button id="readiedInfo" class="qBtn" type="button" aria-label="Readied action details">?</button>
              <button id="reactionOptions" class="btn" type="button">Additional Options</button>
            </div>
          </div>
        </div>

        <div id="statusBar" class="statusBar" role="status" aria-live="polite"></div>
      </section>

      <section class="card" id="combatCard" aria-label="Health and AC">
        <div class="sectionTitle">
          <h2>Health and AC</h2>
          <div class="sub"></div>
        </div>

        <div class="hpGrid">
          <div class="statBox">
            <div class="statLabel">Current HP</div>
            <div class="statValue" id="hpNowText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Max HP</div>
            <div class="statValue" id="hpMaxText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Temp HP</div>
            <div class="statValue" id="hpTempText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">AC</div>
            <div class="statValue" id="acText">10</div>
          </div>
        </div>

        <div class="hpControls">
          <div>
            <label class="label" for="hpMaxInput">Set Max HP</label>
            <input id="hpMaxInput" type="number" min="0" step="1" />
          </div>
          <div>
            <label class="label" for="hpTempInput">Set Temp HP</label>
            <input id="hpTempInput" type="number" min="0" step="1" />
          </div>
          <div>
            <label class="label" for="acInput">Set AC</label>
            <input id="acInput" type="number" min="0" step="1" />
          </div>
          <div class="controls" style="margin-top:0">
            <button id="hpFull" class="btn" type="button">Full Heal</button>
            <button id="hpZeroTemp" class="btn" type="button">Clear Temp</button>
            <button id="openCalc" class="btn" type="button">Open Calculator</button>
          </div>
        </div>
      </section>

      <section class="card" id="spellsCard" aria-label="Spells">
        <div class="sectionTitle">
          <h2 id="spellsSectionTitle">Spells</h2>
          <div class="sub" id="spellsSectionSub">Prepared casters: manage prepared spells. Known casters: manage known spells.</div>
        </div>

        <div class="controls" style="margin-top: 12px;">
          <button id="spellsManageBtn" class="btn" type="button">Manage Spells</button>
          <div class="sub" id="spellsLimitText" style="margin-left:auto;"></div>
        </div>

        <div id="spellsGrid" class="spellGrid"></div>
        <div id="spellsStatus" class="statusBar" role="status" aria-live="polite"></div>
      </section>

      <section class="card" id="abilitiesCard" aria-label="Abilities">
        <div class="sectionTitle">
          <h2>Abilities</h2>
          <div class="sub">Loaded from packages, spend action economy when used.</div>
        </div>
        <div id="abilitiesGrid" class="abilityGrid"></div>
      </section>

      <section class="card" id="passivesCard" aria-label="Passive Abilities">
        <div class="sectionTitle">
          <h2>Passive Abilities</h2>
          <div class="sub">Loaded from packages, reference only.</div>
        </div>
        <div id="passivesGrid" class="abilityGrid"></div>
      </section>

      <footer class="footer">Saved in your browser (localStorage).</footer>

      <dialog id="infoDialog" aria-label="Info dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle" id="dlgTitle">Info</h3>
          <button class="qBtn" id="dlgX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <p id="dlgDesc"></p>
          <div class="dlgMeta" id="dlgMeta"></div>
        </div>
        <div class="dlgActions">
          <button class="btn" id="dlgClose" type="button">Close</button>
        </div>
      </dialog>

      <dialog id="spellbookDialog" aria-label="Spellbook dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle" id="spellbookTitle">Spellbook</h3>
          <button class="qBtn" id="spellbookX" type="button" aria-label="Close dialog">×</button>
        </div>

        <div class="dlgBody">
          <div class="controls" style="margin-top: 0;">
            <input id="spellSearch" type="text" placeholder="Search spells..." />
            <select id="spellLevelFilter">
              <option value="all">All levels</option>
              <option value="0">Cantrips</option>
              <option value="1">Level 1</option>
              <option value="2">Level 2</option>
              <option value="3">Level 3</option>
              <option value="4">Level 4</option>
              <option value="5">Level 5</option>
              <option value="6">Level 6</option>
              <option value="7">Level 7</option>
              <option value="8">Level 8</option>
              <option value="9">Level 9</option>
            </select>
          </div>

          <div class="popupGrid" style="margin-top: 12px;">
            <div class="popupSection">
              <div class="popupSectionTitle" id="spellbookMainTitle">Class Spells</div>
              <div id="spellbookList" class="popupBtns"></div>
            </div>

            <div class="popupSection">
              <div class="popupSectionTitle" id="spellbookRightTitle">Package (Subclass) Spells</div>
              <div id="spellbookRightList" class="popupBtns"></div>
            </div>
          </div>

          <div class="statusBar" id="spellbookStatus" role="status" aria-live="polite"></div>
        </div>

        <div class="dlgActions">
          <button class="btn" id="spellbookClose" type="button">Close</button>
        </div>
      </dialog>

      <dialog id="castDialog" aria-label="Cast spell dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle" id="castTitle">Cast Spell</h3>
          <button class="qBtn" id="castX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <div class="row" style="grid-template-columns: 1fr 280px;">
            <label class="label" for="castSlotLevel">Spell Slot Level</label>
            <select id="castSlotLevel"></select>
          </div>

          <div class="row" style="margin-top: 10px; grid-template-columns: 1fr 280px;">
            <label class="label" for="castEconomy">Consumes</label>
            <select id="castEconomy"></select>
          </div>

          <div class="statBox" style="margin-top: 12px;">
            <div class="statLabel">Spell Details</div>
            <div class="statValue" style="font-size: 13px; font-weight: 500; margin-top: 8px; white-space: pre-wrap;" id="castDetailsText"></div>
          </div>

          <div class="statBox" style="margin-top: 10px;">
            <div class="statLabel">Rules Text</div>
            <div class="statValue" style="font-size: 13px; font-weight: 500; margin-top: 8px; white-space: pre-wrap;" id="castRulesText"></div>
          </div>

          <div class="statBox" style="margin-top: 10px;">
            <div class="statLabel">At Higher Levels</div>
            <div class="statValue" style="font-size: 13px; font-weight: 500; margin-top: 8px; white-space: pre-wrap;" id="castHigherText"></div>
          </div>

          <div class="statusBar" id="castStatus" role="status" aria-live="polite"></div>
        </div>
        <div class="dlgActions">
          <button class="btn" id="castConfirm" type="button">Cast</button>
          <button class="btn" id="castClose" type="button">Close</button>
        </div>
      </dialog>

      <dialog id="calcDialog" aria-label="Calculator dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle">Calculator</h3>
          <button class="qBtn" id="calcX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <div class="calcDisplayBox">
            <div class="calcExpr" id="calcExpr"></div>
            <div class="calcResult" id="calcResult">0</div>
          </div>

          <div class="controls" style="margin-top: 12px">
            <button id="applyAsDamage" class="btn" type="button">Apply Result as Damage</button>
            <button id="applyAsHeal" class="btn" type="button">Apply Result as Healing</button>
            <button id="calcCopy" class="btn" type="button">Copy Result</button>
          </div>

          <div class="calcGrid" id="calcGrid">
            <button class="calcKey danger" data-k="C" type="button">C</button>
            <button class="calcKey" data-k="(" type="button">(</button>
            <button class="calcKey" data-k=")" type="button">)</button>
            <button class="calcKey" data-k="⌫" type="button">⌫</button>

            <button class="calcKey" data-k="7" type="button">7</button>
            <button class="calcKey" data-k="8" type="button">8</button>
            <button class="calcKey" data-k="9" type="button">9</button>
            <button class="calcKey" data-k="/" type="button">÷</button>

            <button class="calcKey" data-k="4" type="button">4</button>
            <button class="calcKey" data-k="5" type="button">5</button>
            <button class="calcKey" data-k="6" type="button">6</button>
            <button class="calcKey" data-k="*" type="button">×</button>

            <button class="calcKey" data-k="1" type="button">1</button>
            <button class="calcKey" data-k="2" type="button">2</button>
            <button class="calcKey" data-k="3" type="button">3</button>
            <button class="calcKey" data-k="-" type="button">−</button>

            <button class="calcKey wide" data-k="0" type="button">0</button>
            <button class="calcKey" data-k="." type="button">.</button>
            <button class="calcKey" data-k="+" type="button">+</button>

            <button class="calcKey ok wide" data-k="=" type="button">=</button>
          </div>

          <div class="statusBar" id="calcStatus" role="status" aria-live="polite"></div>
        </div>
        <div class="dlgActions">
          <button class="btn" id="calcClose" type="button">Close</button>
        </div>
      </dialog>
    </main>

    <script>
      "use strict";

      const SPELLCASTING_URL = "./data/spellcasting.json";
      const SPELLS_URL = "./data/spells.json";

      const STORAGE_KEY = "generic_tracker_state_v5_multiclass_pooled_packages";

      const DEFAULT_ICONS_BASE = "./Icons/";
      const DEFAULT_ACTION_ICONS = {
        action: "Action.webp",
        bonus: "Bonus_action.webp",
        reaction: "Reaction.webp",
        actionUsed: "Action_used.webp",
        bonusUsed: "Bonus_action_used.webp",
        reactionUsed: "Reaction_used.webp",
      };

      function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
      function nint(v, fallback = 0) {
        const x = Number(v);
        return Number.isFinite(x) ? Math.trunc(x) : fallback;
      }

      const READIED_TEXT =
`Readied action (Ready -> then react later)
- On your turn, you use your ACTION to Ready something instead of doing it now.
- You must pick:
  1) A clear trigger (example: "When the ogre steps through the doorway..."), and
  2) The exact response (example: "...I shoot it with my bow," or "...I move behind the pillar.").
- Before the start of your next turn, if the trigger happens, you can use your REACTION to perform the readied response.
- If the trigger never happens (or you choose not to react), the readied action is lost when your next turn starts.
- If you Ready a SPELL, you cast it on your turn and hold it (concentration required), then release it with your reaction when the trigger happens. If you don't release it, the spell slot is still spent.`;

      const GENERIC_ACTION_BUTTONS = [
        { id: "dash", label: "Dash", text: "Dash (move extra up to your speed)" },
        { id: "disengage", label: "Disengage", text: "Disengage (no opportunity attacks from your movement this turn)" },
        { id: "dodge", label: "Dodge", text: "Dodge (attacks vs you have disadvantage, Dex saves have advantage)" },
        { id: "help", label: "Help", text: "Help (give an ally advantage or assist a task)" },
        { id: "hide", label: "Hide", text: "Hide (make a Stealth check to become hidden)" },
        { id: "ready", label: "Ready", text: "Ready (set a trigger, then use your reaction to act)" },
        { id: "search", label: "Search", text: "Search (make a check to find something)" },
        { id: "object", label: "Use an Object / Interact", text: "Use an Object / Interact (open a door, pull a lever, draw or stow an item, etc.)" },
        { id: "improv", label: "Improvised action", text: "Improvised actions (DM call): lift/push/drag, break/force open, swing on a rope, tip a statue, grab a ledge, etc." },
        { id: "throw", label: "Throw something", text: "Throw something (usually an improvised weapon or a thrown weapon, resolved as an attack)" },
      ];

      const el = {};
      let state = loadState();

      let SPELLCASTING = null;
      let SPELLS = null;

      let PACKAGES = [];
      let MERGED_SUPPORT = { meta: {}, resources: {}, abilities: [], passiveAbilities: [], additionalSpells: [] };

      let currentCastSpellId = null;
      let currentCastSourceKey = null;

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) {
            return {
              level: 1,
              multiclass: false,
              classBlocks: [
                { key: "", classLevel: 1, mod: 0, packages: [] },
                { key: "", classLevel: 0, mod: 0, packages: [] },
              ],
              spellSlotsUsed: {},

              // Per class block spell picks (only for class spells)
              preparedSpellsByBlock: {}, // blockKey -> [spellId]
              knownSpellsByBlock: {}, // blockKey -> [spellId]

              // resources
              statA: 0,
              statB: "-",
              statC: "-",

              // action economy
              actionUsed: false,
              bonusUsed: false,
              reactionUsed: false,
              attacksUsed: 0,

              // health & AC
              hpNow: 10,
              hpMax: 10,
              hpTemp: 0,
              acBase: 10,

              // per-rest ability locks (by ability id)
              restLocks: {},

              // calculator
              calcExpr: "",
              calcResult: "0",

              buildManifestUrl: "",
              packageUrls: [],
            };
          }

          const p = JSON.parse(raw);
          const blocks = Array.isArray(p.classBlocks) ? p.classBlocks : [];
          const normBlocks = [
            blocks[0] || { key: "", classLevel: 1, mod: 0, packages: [] },
            blocks[1] || { key: "", classLevel: 0, mod: 0, packages: [] },
          ].map(b => ({
            key: typeof b.key === "string" ? b.key : "",
            classLevel: Math.max(0, nint(b.classLevel, 0)),
            mod: nint(b.mod, 0),
            packages: Array.isArray(b.packages) ? b.packages.filter(x => typeof x === "string") : [],
          }));

          return {
            level: clamp(nint(p.level, 1), 1, 20),
            multiclass: !!p.multiclass,
            classBlocks: normBlocks,
            spellSlotsUsed: (p.spellSlotsUsed && typeof p.spellSlotsUsed === "object") ? p.spellSlotsUsed : {},
            preparedSpellsByBlock: (p.preparedSpellsByBlock && typeof p.preparedSpellsByBlock === "object") ? p.preparedSpellsByBlock : {},
            knownSpellsByBlock: (p.knownSpellsByBlock && typeof p.knownSpellsByBlock === "object") ? p.knownSpellsByBlock : {},

            statA: Number.isFinite(Number(p.statA)) ? Number(p.statA) : 0,
            statB: (p.statB ?? "-"),
            statC: (p.statC ?? "-"),

            actionUsed: !!p.actionUsed,
            bonusUsed: !!p.bonusUsed,
            reactionUsed: !!p.reactionUsed,
            attacksUsed: Math.max(0, nint(p.attacksUsed, 0)),

            hpNow: Math.max(0, nint(p.hpNow, 10)),
            hpMax: Math.max(0, nint(p.hpMax, 10)),
            hpTemp: Math.max(0, nint(p.hpTemp, 0)),
            acBase: Math.max(0, nint(p.acBase, 10)),

            restLocks: (p.restLocks && typeof p.restLocks === "object") ? p.restLocks : {},

            calcExpr: typeof p.calcExpr === "string" ? p.calcExpr : "",
            calcResult: typeof p.calcResult === "string" ? p.calcResult : "0",

            buildManifestUrl: typeof p.buildManifestUrl === "string" ? p.buildManifestUrl : "",
            packageUrls: Array.isArray(p.packageUrls) ? p.packageUrls.filter(x => typeof x === "string") : [],
          };
        } catch {
          return {
            level: 1,
            multiclass: false,
            classBlocks: [
              { key: "", classLevel: 1, mod: 0, packages: [] },
              { key: "", classLevel: 0, mod: 0, packages: [] },
            ],
            spellSlotsUsed: {},
            preparedSpellsByBlock: {},
            knownSpellsByBlock: {},
            statA: 0,
            statB: "-",
            statC: "-",
            actionUsed: false,
            bonusUsed: false,
            reactionUsed: false,
            attacksUsed: 0,
            hpNow: 10,
            hpMax: 10,
            hpTemp: 0,
            acBase: 10,
            restLocks: {},
            calcExpr: "",
            calcResult: "0",
            buildManifestUrl: "",
            packageUrls: [],
          };
        }
      }

      function saveState() { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }

      function normalize() {
        state.level = clamp(nint(state.level, 1), 1, 20);
        state.multiclass = !!state.multiclass;

        if (!Array.isArray(state.classBlocks)) state.classBlocks = [{ key:"", classLevel:1, mod:0, packages:[] }, { key:"", classLevel:0, mod:0, packages:[] }];
        while (state.classBlocks.length < 2) state.classBlocks.push({ key:"", classLevel:0, mod:0, packages:[] });

        for (const b of state.classBlocks) {
          if (typeof b.key !== "string") b.key = "";
          b.classLevel = Math.max(0, nint(b.classLevel, 0));
          b.mod = nint(b.mod, 0);
          if (!Array.isArray(b.packages)) b.packages = [];
          b.packages = b.packages.filter(x => typeof x === "string");
        }

        if (typeof state.spellSlotsUsed !== "object" || !state.spellSlotsUsed) state.spellSlotsUsed = {};
        if (typeof state.preparedSpellsByBlock !== "object" || !state.preparedSpellsByBlock) state.preparedSpellsByBlock = {};
        if (typeof state.knownSpellsByBlock !== "object" || !state.knownSpellsByBlock) state.knownSpellsByBlock = {};

        state.hpMax = Math.max(0, nint(state.hpMax, 0));
        state.hpNow = clamp(nint(state.hpNow, 0), 0, state.hpMax);
        state.hpTemp = Math.max(0, nint(state.hpTemp, 0));
        state.acBase = Math.max(0, nint(state.acBase, 10));
        state.attacksUsed = Math.max(0, nint(state.attacksUsed, 0));

        if (typeof state.restLocks !== "object" || !state.restLocks) state.restLocks = {};
        if (typeof state.calcExpr !== "string") state.calcExpr = "";
        if (typeof state.calcResult !== "string") state.calcResult = "0";

        if (typeof state.buildManifestUrl !== "string") state.buildManifestUrl = "";
        if (!Array.isArray(state.packageUrls)) state.packageUrls = [];
        state.packageUrls = state.packageUrls.filter(x => typeof x === "string");
      }

      function setStatus(msg, kind = "") {
        el.statusBar.textContent = msg || "";
        el.statusBar.classList.remove("ok", "error");
        if (kind) el.statusBar.classList.add(kind);
      }
      function setSpellStatus(msg, kind = "") {
        el.spellStatus.textContent = msg || "";
        el.spellStatus.classList.remove("ok", "error");
        if (kind) el.spellStatus.classList.add(kind);
      }
      function setSpellsStatus(msg, kind = "") {
        el.spellsStatus.textContent = msg || "";
        el.spellsStatus.classList.remove("ok", "error");
        if (kind) el.spellsStatus.classList.add(kind);
      }
      function setSpellbookStatus(msg, kind = "") {
        el.spellbookStatus.textContent = msg || "";
        el.spellbookStatus.classList.remove("ok", "error");
        if (kind) el.spellbookStatus.classList.add(kind);
      }
      function setCastStatus(msg, kind = "") {
        el.castStatus.textContent = msg || "";
        el.castStatus.classList.remove("ok", "error");
        if (kind) el.castStatus.classList.add(kind);
      }
      function setCalcStatus(msg, kind = "") {
        el.calcStatus.textContent = msg || "";
        el.calcStatus.classList.remove("ok", "error");
        if (kind) el.calcStatus.classList.add(kind);
      }

      function openDialog(title, desc, meta) {
        el.dlgTitle.textContent = title;
        el.dlgDesc.textContent = desc;
        el.dlgMeta.textContent = meta || "";
        if (typeof el.infoDialog.showModal === "function") el.infoDialog.showModal();
        else alert(`${title}\n\n${desc}\n\n${meta || ""}`);
      }

      function actionTypeLabel(actionType) {
        if (actionType === "bonus") return "Bonus Action";
        if (actionType === "reaction") return "Reaction";
        if (actionType === "action") return "Action";
        return "Passive";
      }

      function getIconsBase() {
        return (MERGED_SUPPORT && MERGED_SUPPORT.meta && MERGED_SUPPORT.meta.iconsBase) ? MERGED_SUPPORT.meta.iconsBase : DEFAULT_ICONS_BASE;
      }

      function getActionIcons() {
        return (MERGED_SUPPORT && MERGED_SUPPORT.meta && MERGED_SUPPORT.meta.actionIcons) ? MERGED_SUPPORT.meta.actionIcons : DEFAULT_ACTION_ICONS;
      }

      function getMaxAttacksPerTurn() {
        const v = MERGED_SUPPORT && MERGED_SUPPORT.meta && Number.isFinite(Number(MERGED_SUPPORT.meta.maxAttacksPerTurn))
          ? Number(MERGED_SUPPORT.meta.maxAttacksPerTurn)
          : 1;
        return Math.max(1, Math.trunc(v));
      }

      async function fetchJson(url) {
        const res = await fetch(url, { cache: "no-store" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        return await res.json();
      }

      function mergeSupportPackages(pkgs) {
        const merged = { meta: {}, resources: {}, abilities: [], passiveAbilities: [], additionalSpells: [] };
        for (const p of pkgs) {
          if (!p || typeof p !== "object") continue;
          if (p.meta && typeof p.meta === "object") merged.meta = { ...merged.meta, ...p.meta };
          if (p.resources && typeof p.resources === "object") merged.resources = { ...merged.resources, ...p.resources };
          if (Array.isArray(p.abilities)) merged.abilities.push(...p.abilities);
          if (Array.isArray(p.passiveAbilities)) merged.passiveAbilities.push(...p.passiveAbilities);
          if (Array.isArray(p.additionalSpells)) merged.additionalSpells.push(...p.additionalSpells);
        }
        return merged;
      }

      function getActiveBlocks() {
        const blocks = [];
        blocks.push({ idx: 0, key: "main", ...state.classBlocks[0] });
        if (state.multiclass) blocks.push({ idx: 1, key: "mc1", ...state.classBlocks[1] });
        return blocks;
      }

      async function loadPackages() {
        PACKAGES = [];

        const urls = state.packageUrls.slice();
        const blocks = getActiveBlocks();
        for (const b of blocks) {
          for (const u of (state.classBlocks[b.idx].packages || [])) {
            if (typeof u === "string" && u.trim()) urls.push(u.trim());
          }
        }

        const unique = [];
        const seen = new Set();
        for (const u of urls) {
          const k = String(u).trim();
          if (!k || seen.has(k)) continue;
          seen.add(k);
          unique.push(k);
        }

        for (const u of unique) {
          try {
            const j = await fetchJson(u);
            PACKAGES.push(j);
          } catch {
            // do not break
          }
        }

        MERGED_SUPPORT = mergeSupportPackages(PACKAGES);
      }

      function renderResourcesFromPackages() {
        const A = MERGED_SUPPORT.resources && MERGED_SUPPORT.resources.A ? MERGED_SUPPORT.resources.A : null;
        const B = MERGED_SUPPORT.resources && MERGED_SUPPORT.resources.B ? MERGED_SUPPORT.resources.B : null;
        const C = MERGED_SUPPORT.resources && MERGED_SUPPORT.resources.C ? MERGED_SUPPORT.resources.C : null;

        if (A && typeof A.label === "string") {
          el.statALabel.textContent = A.label;
          if (typeof A.value === "number") state.statA = A.value;
        } else el.statALabel.textContent = "Resource A";

        if (B && typeof B.label === "string") {
          el.statBLabel.textContent = B.label;
          if (typeof B.value !== "undefined") state.statB = B.value;
        } else el.statBLabel.textContent = "Resource B";

        if (C && typeof C.label === "string") {
          el.statCLabel.textContent = C.label;
          if (typeof C.value !== "undefined") state.statC = C.value;
        } else el.statCLabel.textContent = "Resource C";
      }

      async function loadSpellcasting() {
        try {
          SPELLCASTING = await fetchJson(SPELLCASTING_URL);
          return true;
        } catch {
          SPELLCASTING = null;
          setSpellStatus(`Failed to load spellcasting: ${SPELLCASTING_URL}`, "error");
          return false;
        }
      }

      async function loadSpellsIfNeeded() {
        if (SPELLS) return true;
        try {
          SPELLS = await fetchJson(SPELLS_URL);
          return true;
        } catch {
          SPELLS = null;
          setSpellbookStatus(`Failed to load spells: ${SPELLS_URL}`, "error");
          return false;
        }
      }

      function getSpellDef(spellId) {
        if (!SPELLS) return null;
        if (SPELLS.spells && Array.isArray(SPELLS.spells)) {
          for (const s of SPELLS.spells) if (s && s.id === spellId) return s;
        }
        if (SPELLS.spells && SPELLS.spells[spellId]) return SPELLS.spells[spellId];
        if (SPELLS[spellId]) return SPELLS[spellId];
        return null;
      }

      function spellLevelLabel(lv) {
        const n = Number(lv);
        if (!Number.isFinite(n)) return "Unknown";
        if (n === 0) return "Cantrip";
        return `Level ${n}`;
      }

      function safeStr(v) { return (typeof v === "string") ? v : ""; }

      function formatSpellDetails(s) {
        if (!s) return "";
        const parts = [];
        const lvl = Number.isFinite(Number(s.level)) ? Number(s.level) : 0;
        const school = s.school || s.schoolName || "";
        parts.push(`${spellLevelLabel(lvl)}${school ? " " + school : ""}`);
        const ct = s.castingTime || s.casting_time || s.time || "";
        if (ct) parts.push(`Casting Time: ${ct}`);
        if (s.range) parts.push(`Range: ${s.range}`);
        if (s.components) parts.push(`Components: ${s.components}`);
        if (s.duration) parts.push(`Duration: ${s.duration}`);
        if (typeof s.ritual === "boolean") parts.push(`Ritual: ${s.ritual ? "Yes" : "No"}`);
        if (typeof s.concentration === "boolean") parts.push(`Concentration: ${s.concentration ? "Yes" : "No"}`);
        return parts.join("\n");
      }

      function splitHigherLevels(s) {
        const higher = safeStr(s.higherLevels || s.higher_levels || s.atHigherLevels || s.higher);
        const desc = safeStr(s.description || s.desc || s.text || s.rulesText);
        if (higher.trim()) return { base: desc.trim(), higher: higher.trim() };

        const idx = desc.toLowerCase().indexOf("at higher levels");
        if (idx === -1) return { base: desc.trim(), higher: "" };
        const base = desc.slice(0, idx).trim();
        let rest = desc.slice(idx).trim();
        rest = rest.replace(/^at higher levels\s*[:.\-]?\s*/i, "");
        return { base, higher: rest.trim() };
      }

      function inferEconomyFromCastingTime(ct) {
        const t = String(ct || "").toLowerCase();
        if (t.includes("reaction")) return "reaction";
        if (t.includes("bonus")) return "bonus";
        return "action";
      }

      function getClassDef(classKey) {
        if (!SPELLCASTING || !SPELLCASTING.classes) return null;
        return SPELLCASTING.classes[classKey] || null;
      }

      function isPreparedCaster(classDef) {
        if (!classDef) return false;
        if (classDef.type === "prepared") return true;
        if (classDef.prepared && classDef.prepared.type === "prepared") return true;
        return false;
      }

      function isKnownCaster(classDef) {
        if (!classDef) return false;
        return classDef.type === "known";
      }

      function isPactCaster(classDef) {
        if (!classDef) return false;
        if (classDef.type === "pact") return true;
        const progKey = classDef.progressionKey || classDef.progression;
        const prog = (SPELLCASTING && SPELLCASTING.progressions && progKey) ? (SPELLCASTING.progressions[progKey] || null) : null;
        return !!(prog && prog.pactMagicTable);
      }

      function spellAbilityLabelForClass(classDef) {
        const a = String(classDef && (classDef.spellAbility || (classDef.prepared && classDef.prepared.ability) || classDef.ability) || "").toUpperCase();
        if (a.includes("INT")) return "INT";
        if (a.includes("WIS")) return "WIS";
        if (a.includes("CHA")) return "CHA";
        return "Mod";
      }

      function computePreparedLimit(classDef, classLevel, mod) {
        if (!isPreparedCaster(classDef)) return 0;
        const lvl = Math.max(1, nint(classLevel, 1));
        const m = nint(mod, 0);
        const f = String((classDef.prepared && classDef.prepared.formula) || classDef.preparedFormula || "").toUpperCase();
        let val = 0;
        if (f.includes("/2") || f.includes("LEVEL/2")) val = m + Math.floor(lvl / 2);
        else val = m + lvl;

        const min = Number.isFinite(Number((classDef.prepared && classDef.prepared.min) || classDef.preparedMin)) ? Number((classDef.prepared && classDef.prepared.min) || classDef.preparedMin) : 1;
        return Math.max(min, Math.trunc(val));
      }

      function computeKnownLimit(classDef, classLevel) {
        if (!isKnownCaster(classDef)) return 0;
        const lvl = Math.max(1, nint(classLevel, 1));
        if (classDef.knownTable && typeof classDef.knownTable === "object") {
          const v = classDef.knownTable[String(lvl)] ?? classDef.knownTable[lvl];
          if (Number.isFinite(Number(v))) return Math.max(0, Math.trunc(Number(v)));
        }
        return 0;
      }

      function getClassSpellIdsForClassKey(classKey) {
        const cd = getClassDef(classKey);
        if (!cd || !cd.spellListByLevel) return [];
        const keys = Object.keys(cd.spellListByLevel).map(x => Number(x)).filter(n => Number.isFinite(n));
        keys.sort((a,b)=>a-b);
        const out = [];
        for (const k of keys) {
          const arr = cd.spellListByLevel[String(k)];
          if (!Array.isArray(arr)) continue;
          for (const it of arr) if (it && it.id) out.push(it.id);
        }
        return Array.from(new Set(out));
      }

      function getPackageSpellIdsForClassKey(classKey) {
        const out = [];
        const list = (MERGED_SUPPORT && Array.isArray(MERGED_SUPPORT.additionalSpells)) ? MERGED_SUPPORT.additionalSpells : [];
        for (const entry of list) {
          if (!entry || typeof entry !== "object") continue;
          if (String(entry.classKey || "") !== String(classKey || "")) continue;
          const byLevel = entry.spellsByLevel;
          if (!byLevel || typeof byLevel !== "object") continue;
          for (const k of Object.keys(byLevel)) {
            const arr = byLevel[k];
            if (!Array.isArray(arr)) continue;
            for (const sid of arr) if (typeof sid === "string") out.push(sid);
          }
        }
        return Array.from(new Set(out));
      }

      function getGrantedSpellIdsForClassKey(classKey) {
        // Granted spells are package spells not in class list
        const base = new Set(getClassSpellIdsForClassKey(classKey));
        const pkg = getPackageSpellIdsForClassKey(classKey);
        return pkg.filter(id => !base.has(id));
      }

      /* ---------- Action economy ---------- */
      function consumeEconomy(kind) {
        if (kind === "action") {
          if (state.actionUsed) return false;
          state.actionUsed = true;
          // If you spend your action on anything, you cannot use Basic Attack.
          state.attacksUsed = getMaxAttacksPerTurn();
          return true;
        }
        if (kind === "bonus") {
          if (state.bonusUsed) return false;
          state.bonusUsed = true;
          return true;
        }
        if (kind === "reaction") {
          if (state.reactionUsed) return false;
          state.reactionUsed = true;
          return true;
        }
        return true;
      }

      function useActionAttack() {
        const maxAttacks = getMaxAttacksPerTurn();
        if (state.actionUsed) return false;
        if (state.attacksUsed >= maxAttacks) return false;
        state.actionUsed = true;
        state.attacksUsed += 1;
        return true;
      }

      function nextTurn() {
        state.actionUsed = false;
        state.bonusUsed = false;
        state.reactionUsed = false;
        state.attacksUsed = 0;
        saveState();
        render();
        setStatus("Next turn: action economy refreshed.", "ok");
      }

      /* ---------- Rest ---------- */
      function doShortRest() {
        // clear short-rest locks on abilities
        for (const a of (MERGED_SUPPORT.abilities || [])) {
          if (a && a.id && a.usage && a.usage.type === "oncePerShortRest") delete state.restLocks[a.id];
        }

        // reset pact slots on short rest
        const blocks = getActiveBlocks();
        for (const b of blocks) {
          const cd = getClassDef(state.classBlocks[b.idx].key);
          if (cd && isPactCaster(cd)) {
            setUsedSlots("pact:" + b.key, "pact", 0);
          }
        }

        saveState();
        render();
        setStatus("Short rest: short-rest locks cleared, pact slots refreshed.", "ok");
      }

      function doLongRest() {
        // clear short/long rest locks
        for (const a of (MERGED_SUPPORT.abilities || [])) {
          if (a && a.id && a.usage && (a.usage.type === "oncePerShortRest" || a.usage.type === "oncePerLongRest")) delete state.restLocks[a.id];
        }

        // reset all spell slots (pooled + pact)
        state.spellSlotsUsed = {};
        saveState();
        render();
        setStatus("Long rest: locks cleared and spell slots refreshed.", "ok");
      }

      /* ---------- HP ---------- */
      function applyDamage(amount) {
        amount = Math.max(0, Number(amount) || 0);
        if (amount <= 0) return { usedTemp: 0, usedHp: 0 };
        const usedTemp = Math.min(state.hpTemp, amount);
        state.hpTemp -= usedTemp;
        const remaining = amount - usedTemp;
        const usedHp = Math.min(state.hpNow, remaining);
        state.hpNow -= usedHp;
        return { usedTemp, usedHp };
      }

      function applyHeal(amount) {
        amount = Math.max(0, Number(amount) || 0);
        if (amount <= 0) return 0;
        const before = state.hpNow;
        state.hpNow = Math.min(state.hpMax, state.hpNow + amount);
        return state.hpNow - before;
      }

      /* ---------- Storage helpers for slots ---------- */
      function slotKey(bucket, levelKey) { return `${bucket}:${levelKey}`; }
      function getUsedSlots(bucket, levelKey) {
        const v = state.spellSlotsUsed[slotKey(bucket, levelKey)];
        return Math.max(0, nint(v, 0));
      }
      function setUsedSlots(bucket, levelKey, used) {
        state.spellSlotsUsed[slotKey(bucket, levelKey)] = Math.max(0, nint(used, 0));
      }

      function resetAllSlots() {
        state.spellSlotsUsed = {};
        saveState();
      }

      /* ---------- Multiclass pooled slot math ---------- */
      function canPoolSlots() {
        return !!(SPELLCASTING && SPELLCASTING.meta && SPELLCASTING.meta.multiclassPooling === true);
      }

      function computeCasterLevelPooled() {
        // Uses spellcasting.json class fields if present:
        // - multiclassFactor {numerator, denominator, rounding}
        // Fallback inference by progressionKey naming.
        const blocks = getActiveBlocks();
        let total = 0;

        for (const b of blocks) {
          const ck = state.classBlocks[b.idx].key;
          const cd = getClassDef(ck);
          if (!cd) continue;

          if (isPactCaster(cd)) continue;

          if (cd.multiclassFactor && typeof cd.multiclassFactor === "object") {
            const num = Number(cd.multiclassFactor.numerator);
            const den = Number(cd.multiclassFactor.denominator);
            const rnd = String(cd.multiclassFactor.rounding || "down");
            if (Number.isFinite(num) && Number.isFinite(den) && den > 0) {
              const raw = (state.classBlocks[b.idx].classLevel * num) / den;
              total += (rnd === "up") ? Math.ceil(raw) : Math.floor(raw);
              continue;
            }
          }

          const progKey = String(cd.progressionKey || cd.progression || "").toLowerCase();
          const lvl = state.classBlocks[b.idx].classLevel;

          if (progKey.includes("full")) total += lvl;
          else if (progKey.includes("half")) total += Math.floor(lvl / 2);
          else if (progKey.includes("third")) total += Math.floor(lvl / 3);
          else total += lvl;
        }

        return clamp(total, 1, 20);
      }

      function getPooledSlotsForCasterLevel(casterLevel) {
        // Prefer "full" progression table as the pooled table (5e standard)
        const progs = (SPELLCASTING && SPELLCASTING.progressions) ? SPELLCASTING.progressions : null;
        if (!progs) return [];
        let full = null;

        for (const k of Object.keys(progs)) {
          const p = progs[k];
          if (!p || !p.slotTable) continue;
          if (String(k).toLowerCase().includes("full")) { full = p; break; }
        }
        if (!full) {
          for (const k of Object.keys(progs)) {
            const p = progs[k];
            if (p && p.slotTable) { full = p; break; }
          }
        }

        if (!full || !full.slotTable) return [];
        const lvl = clamp(nint(casterLevel, 1), 1, 20);
        const arr = full.slotTable[String(lvl)] || full.slotTable[lvl];
        if (!Array.isArray(arr)) return [];
        return arr.map(x => Math.max(0, nint(x, 0)));
      }

      function renderStandardSlotsBar(bucket, levelsArr, label) {
        const header = document.createElement("div");
        header.className = "sub";
        header.textContent = `${label}`;
        el.spellSlotsWrap.appendChild(header);

        for (let idx = 0; idx < levelsArr.length; idx++) {
          const max = levelsArr[idx];
          const spellLevel = idx + 1;
          if (max <= 0) continue;

          const levelKey = String(spellLevel);
          const used = clamp(getUsedSlots(bucket, levelKey), 0, max);
          if (used !== getUsedSlots(bucket, levelKey)) setUsedSlots(bucket, levelKey, used);

          const row = document.createElement("div");
          row.className = "slotRow";

          const left = document.createElement("div");
          left.className = "slotLabel";
          left.textContent = `Level ${spellLevel}`;

          const right = document.createElement("div");
          right.className = "slotBubbles";

          for (let i = 0; i < max; i++) {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "slotBubble" + (i < used ? " used" : "");
            btn.textContent = String(spellLevel);
            btn.addEventListener("click", async () => {
              const nowUsed = getUsedSlots(bucket, levelKey);
              const nextUsed = (i < nowUsed) ? i : (i + 1);
              setUsedSlots(bucket, levelKey, clamp(nextUsed, 0, max));
              saveState();
              await render();
            });
            right.appendChild(btn);
          }

          row.appendChild(left);
          row.appendChild(right);
          el.spellSlotsWrap.appendChild(row);
        }
      }

      function renderPactSlotsBar(bucket, slots, label) {
        const header = document.createElement("div");
        header.className = "sub";
        header.textContent = `${label} Pact Magic (Slot Level ${slots.slotLevel})`;
        el.spellSlotsWrap.appendChild(header);

        const row = document.createElement("div");
        row.className = "slotRow";

        const left = document.createElement("div");
        left.className = "slotLabel";
        left.textContent = `Pact Slots (L${slots.slotLevel})`;

        const right = document.createElement("div");
        right.className = "slotBubbles";

        const used = clamp(getUsedSlots(bucket, "pact"), 0, slots.slots);
        if (used !== getUsedSlots(bucket, "pact")) setUsedSlots(bucket, "pact", used);

        for (let i = 0; i < slots.slots; i++) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "slotBubble" + (i < used ? " used" : "");
          btn.textContent = "★";
          btn.addEventListener("click", async () => {
            const nowUsed = getUsedSlots(bucket, "pact");
            const nextUsed = (i < nowUsed) ? i : (i + 1);
            setUsedSlots(bucket, "pact", clamp(nextUsed, 0, slots.slots));
            saveState();
            await render();
          });
          right.appendChild(btn);
        }

        row.appendChild(left);
        row.appendChild(right);
        el.spellSlotsWrap.appendChild(row);
      }

      function getPactSlotsForClassAtLevel(classDef, classLevel) {
        const progKey = classDef.progressionKey || classDef.progression;
        const prog = (SPELLCASTING && SPELLCASTING.progressions && progKey) ? (SPELLCASTING.progressions[progKey] || null) : null;
        if (!prog || !prog.pactMagicTable) return null;
        const lvl = clamp(nint(classLevel, 1), 1, 20);
        const row = prog.pactMagicTable[String(lvl)] || prog.pactMagicTable[lvl];
        if (!row) return { slots: 0, slotLevel: 1 };
        return { slots: Math.max(0, nint(row.slots, 0)), slotLevel: Math.max(1, nint(row.slotLevel, 1)) };
      }

      function renderSpellSlots() {
        el.spellSlotsWrap.innerHTML = "";
        el.spellMetaText.textContent = "";

        if (!SPELLCASTING) {
          el.spellMetaText.textContent = "Spellcasting rules not loaded.";
          return;
        }

        const blocks = getActiveBlocks();
        const sum = blocks.reduce((a,b)=>a + Math.max(0, nint(state.classBlocks[b.idx].classLevel, 0)), 0);
        if (sum !== state.level) {
          el.classWarning.textContent = `Class levels sum to ${sum}. Character level is ${state.level}. Slots and spell limits use class levels.`;
        } else {
          el.classWarning.textContent = "";
        }

        const usePooling = (blocks.length > 1) && canPoolSlots();
        if (usePooling) {
          const casterLevel = computeCasterLevelPooled();
          const pooled = getPooledSlotsForCasterLevel(casterLevel);
          renderStandardSlotsBar("pooled", pooled, `Pooled Spell Slots (Caster Level ${casterLevel})`);

          // Pact magic remains separate
          for (const b of blocks) {
            const ck = state.classBlocks[b.idx].key;
            const cd = getClassDef(ck);
            if (!cd || !isPactCaster(cd)) continue;
            const pact = getPactSlotsForClassAtLevel(cd, state.classBlocks[b.idx].classLevel);
            if (pact) renderPactSlotsBar("pact:" + b.key, pact, ck);
          }
          return;
        }

        // If single class or pooling disabled in json, show per class
        for (const b of blocks) {
          const ck = state.classBlocks[b.idx].key;
          const cd = getClassDef(ck);
          if (!cd) continue;

          if (isPactCaster(cd)) {
            const pact = getPactSlotsForClassAtLevel(cd, state.classBlocks[b.idx].classLevel);
            if (pact) renderPactSlotsBar("pact:" + b.key, pact, ck);
            continue;
          }

          const progKey = cd.progressionKey || cd.progression;
          const prog = (SPELLCASTING && SPELLCASTING.progressions && progKey) ? (SPELLCASTING.progressions[progKey] || null) : null;
          const lvl = clamp(nint(state.classBlocks[b.idx].classLevel, 1), 1, 20);
          const arr = prog && prog.slotTable ? (prog.slotTable[String(lvl)] || prog.slotTable[lvl]) : null;
          const levels = Array.isArray(arr) ? arr.map(x => Math.max(0, nint(x, 0))) : [];
          renderStandardSlotsBar(ck, levels, `${ck} Slots`);
        }
      }

      /* ---------- Spells: picks + display ---------- */
      function getBlockSpellPickList(blockKey, kind) {
        const obj = (kind === "prepared") ? state.preparedSpellsByBlock : state.knownSpellsByBlock;
        const arr = obj[blockKey];
        if (!Array.isArray(arr)) return [];
        return arr.filter(x => typeof x === "string");
      }

      function setBlockSpellPickList(blockKey, kind, list) {
        const obj = (kind === "prepared") ? state.preparedSpellsByBlock : state.knownSpellsByBlock;
        obj[blockKey] = Array.from(new Set((list || []).filter(x => typeof x === "string")));
      }

      function getCombinedSpellCardsToRender() {
        // What appears in the spells section are spells you can cast:
        // - prepared spells (prepared casters)
        // - known spells (known casters)
        // - granted spells (packages) (always available)
        const blocks = getActiveBlocks();
        const out = [];

        for (const b of blocks) {
          const classKey = state.classBlocks[b.idx].key;
          if (!classKey) continue;

          const cd = getClassDef(classKey);
          if (!cd) continue;

          const granted = getGrantedSpellIdsForClassKey(classKey).map(id => ({
            id, source: "granted", blockKey: b.key, classKey
          }));

          if (isPreparedCaster(cd)) {
            const prepared = getBlockSpellPickList(b.key, "prepared").map(id => ({
              id, source: "prepared", blockKey: b.key, classKey
            }));
            out.push(...prepared, ...granted);
          } else if (isKnownCaster(cd) || isPactCaster(cd)) {
            const known = getBlockSpellPickList(b.key, "known").map(id => ({
              id, source: "known", blockKey: b.key, classKey
            }));
            out.push(...known, ...granted);
          } else {
            out.push(...granted);
          }
        }

        // de-dupe by (id + source + blockKey), but allow same spell in different class blocks
        const seen = new Set();
        const dedup = [];
        for (const x of out) {
          const k = `${x.blockKey}|${x.source}|${x.id}`;
          if (seen.has(k)) continue;
          seen.add(k);
          dedup.push(x);
        }
        return dedup;
      }

      function renderSpellsSection() {
        el.spellsGrid.innerHTML = "";
        setSpellsStatus("");

        const blocks = getActiveBlocks();
        const visibleBlocks = blocks.map(b => state.classBlocks[b.idx].key).filter(Boolean);
        el.spellsSectionTitle.textContent = (visibleBlocks.length <= 1)
          ? "Spells"
          : `Spells (${visibleBlocks.join(" + ")})`;

        // Prepare limit text
        const parts = [];
        for (const b of blocks) {
          const classKey = state.classBlocks[b.idx].key;
          if (!classKey) continue;
          const cd = getClassDef(classKey);
          if (!cd) continue;

          if (isPreparedCaster(cd)) {
            const limit = computePreparedLimit(cd, state.classBlocks[b.idx].classLevel, state.classBlocks[b.idx].mod);
            const picked = getBlockSpellPickList(b.key, "prepared").length;
            parts.push(`${classKey}: Prepared ${picked}/${limit}`);
          } else if (isKnownCaster(cd) || isPactCaster(cd)) {
            const limit = computeKnownLimit(cd, state.classBlocks[b.idx].classLevel);
            const picked = getBlockSpellPickList(b.key, "known").length;
            parts.push(limit > 0 ? `${classKey}: Known ${picked}/${limit}` : `${classKey}: Known ${picked}`);
          }
        }
        el.spellsLimitText.textContent = parts.join("   |   ");

        const cards = getCombinedSpellCardsToRender();
        if (cards.length === 0) {
          const e = document.createElement("div");
          e.className = "sub";
          e.textContent = "No spells selected yet. Use Manage Spells or load package spells.";
          el.spellsGrid.appendChild(e);
          return;
        }

        for (const c of cards) {
          const def = getSpellDef(c.id);
          const name = def ? (def.name || c.id) : c.id;
          const level = def ? Number(def.level) : NaN;
          const ct = def ? (def.castingTime || def.casting_time || def.time || "") : "";
          const econ = inferEconomyFromCastingTime(ct);
          const sourceTag = (c.source === "granted") ? "Granted" : (c.source === "prepared" ? "Prepared" : "Known");

          const card = document.createElement("div");
          card.className = "spellCard";

          const left = document.createElement("div");
          const nm = document.createElement("div");
          nm.className = "spellName";
          nm.textContent = name;

          const meta = document.createElement("div");
          meta.className = "spellMeta";
          meta.textContent = `${sourceTag} | ${spellLevelLabel(level)} | ${ct || "Casting: (unknown)"}`;

          left.appendChild(nm);
          left.appendChild(meta);

          const btns = document.createElement("div");
          btns.className = "spellBtns";

          const castBtn = document.createElement("button");
          castBtn.className = "btn";
          castBtn.type = "button";
          castBtn.textContent = "Cast";
          castBtn.addEventListener("click", async () => {
            await openCastDialog(c.id, c.classKey, c.source);
          });

          const q = document.createElement("button");
          q.className = "qBtn";
          q.type = "button";
          q.textContent = "?";
          q.addEventListener("click", () => {
            const s = getSpellDef(c.id);
            if (!s) { openDialog(name, "Spell definition not found in spells.json.", `${sourceTag} | ${c.classKey}`); return; }
            const details = formatSpellDetails(s);
            const split = splitHigherLevels(s);
            const fullText = [
              split.base || "",
              split.higher ? ("\nAt Higher Levels:\n" + split.higher) : ""
            ].join("").trim();

            openDialog(s.name || c.id, fullText || "(No text)", details);
          });

          btns.appendChild(castBtn);
          btns.appendChild(q);

          card.appendChild(left);
          card.appendChild(btns);
          el.spellsGrid.appendChild(card);
        }
      }

      /* ---------- Cast dialog ---------- */
      function getRemainingSlotsForLevel(bucket, levelKey, max) {
        const used = getUsedSlots(bucket, levelKey);
        return Math.max(0, max - used);
      }

      function getAvailableSlotOptionsForSpell(spellDef, classKey) {
        const options = [];
        if (!spellDef) return options;

        const spellLevel = Number.isFinite(Number(spellDef.level)) ? Number(spellDef.level) : 0;
        if (spellLevel === 0) {
          options.push({ key: "cantrip", label: "Cantrip (no slot)", bucket: "", levelKey: "", max: 0 });
          return options;
        }

        const blocks = getActiveBlocks();
        const multi = (blocks.length > 1) && canPoolSlots();
        const cd = getClassDef(classKey);

        // Standard pooled slots
        if (multi) {
          const casterLevel = computeCasterLevelPooled();
          const pooled = getPooledSlotsForCasterLevel(casterLevel);
          for (let i = spellLevel; i <= 9; i++) {
            const max = pooled[i - 1] || 0;
            if (max <= 0) continue;
            const remaining = getRemainingSlotsForLevel("pooled", String(i), max);
            options.push({ key: String(i), label: `Slot ${i} (remaining ${remaining}/${max})`, bucket: "pooled", levelKey: String(i), max });
          }
        } else {
          // single class standard
          if (cd && !isPactCaster(cd)) {
            const progKey = cd.progressionKey || cd.progression;
            const prog = (SPELLCASTING && SPELLCASTING.progressions && progKey) ? (SPELLCASTING.progressions[progKey] || null) : null;
            const lvl = clamp(nint(getClassLevelForClassKey(classKey), 1), 1, 20);
            const arr = prog && prog.slotTable ? (prog.slotTable[String(lvl)] || prog.slotTable[lvl]) : null;
            const levels = Array.isArray(arr) ? arr.map(x => Math.max(0, nint(x, 0))) : [];
            for (let i = spellLevel; i <= 9; i++) {
              const max = levels[i - 1] || 0;
              if (max <= 0) continue;
              const remaining = getRemainingSlotsForLevel(classKey, String(i), max);
              options.push({ key: String(i), label: `Slot ${i} (remaining ${remaining}/${max})`, bucket: classKey, levelKey: String(i), max });
            }
          }
        }

        // Pact magic slots (if class is warlock, etc.), allow only at its pact level
        if (cd && isPactCaster(cd)) {
          // Find which active block matches this classKey
          const b = findBlockForClassKey(classKey);
          if (b) {
            const pact = getPactSlotsForClassAtLevel(cd, state.classBlocks[b.idx].classLevel);
            if (pact && pact.slots > 0) {
              const pactLevel = pact.slotLevel;
              if (pactLevel >= spellLevel) {
                const bucket = "pact:" + b.key;
                const used = getUsedSlots(bucket, "pact");
                const remaining = Math.max(0, pact.slots - used);
                options.push({ key: "pact", label: `Pact Slot L${pactLevel} (remaining ${remaining}/${pact.slots})`, bucket, levelKey: "pact", max: pact.slots, pactLevel });
              }
            }
          }
        }

        return options;
      }

      function getClassLevelForClassKey(classKey) {
        const blocks = getActiveBlocks();
        for (const b of blocks) {
          if (state.classBlocks[b.idx].key === classKey) return state.classBlocks[b.idx].classLevel;
        }
        return state.level;
      }

      function findBlockForClassKey(classKey) {
        const blocks = getActiveBlocks();
        for (const b of blocks) {
          if (state.classBlocks[b.idx].key === classKey) return b;
        }
        return null;
      }

      async function openCastDialog(spellId, classKey, sourceKind) {
        await loadSpellsIfNeeded();

        const s = getSpellDef(spellId);
        if (!s) {
          setSpellsStatus("Spell definition missing in spells.json.", "error");
          return;
        }

        currentCastSpellId = spellId;
        currentCastSourceKey = classKey;

        el.castTitle.textContent = `Cast: ${s.name || spellId}`;

        // Economy select: inferred from casting time, but editable
        const ct = s.castingTime || s.casting_time || s.time || "";
        const inferred = inferEconomyFromCastingTime(ct);
        el.castEconomy.innerHTML = "";

        const econOpts = [
          { v: "action", t: "Action" },
          { v: "bonus", t: "Bonus Action" },
          { v: "reaction", t: "Reaction" },
          { v: "none", t: "No Action (reference)" },
        ];
        for (const o of econOpts) {
          const opt = document.createElement("option");
          opt.value = o.v;
          opt.textContent = o.t;
          el.castEconomy.appendChild(opt);
        }
        el.castEconomy.value = inferred;

        const details = formatSpellDetails(s);
        const split = splitHigherLevels(s);

        el.castDetailsText.textContent = details || "";
        el.castRulesText.textContent = split.base || "";
        el.castHigherText.textContent = split.higher || "(None)";

        // Slot level select
        const slotOpts = getAvailableSlotOptionsForSpell(s, classKey);
        el.castSlotLevel.innerHTML = "";
        if (slotOpts.length === 0) {
          const opt = document.createElement("option");
          opt.value = "none";
          opt.textContent = "No slot options available";
          el.castSlotLevel.appendChild(opt);
          el.castSlotLevel.disabled = true;
        } else {
          el.castSlotLevel.disabled = false;
          for (const o of slotOpts) {
            const opt = document.createElement("option");
            opt.value = o.key;
            opt.textContent = o.label;
            opt.dataset.bucket = o.bucket;
            opt.dataset.levelKey = o.levelKey;
            opt.dataset.max = String(o.max || 0);
            opt.dataset.pactLevel = String(o.pactLevel || "");
            el.castSlotLevel.appendChild(opt);
          }
        }

        setCastStatus("");

        if (typeof el.castDialog.showModal === "function") el.castDialog.showModal();
        else alert("Cast dialog not supported in this browser.");
      }

      function castConfirm() {
        if (!currentCastSpellId || !currentCastSourceKey) return;

        const s = getSpellDef(currentCastSpellId);
        if (!s) { setCastStatus("Spell definition missing.", "error"); return; }

        const econ = String(el.castEconomy.value || "action");
        if (econ !== "none") {
          if (!consumeEconomy(econ)) {
            setCastStatus(`${actionTypeLabel(econ)} already used this turn.`, "error");
            return;
          }
        }

        const spellLevel = Number.isFinite(Number(s.level)) ? Number(s.level) : 0;

        // Spend slot (unless cantrip)
        if (spellLevel > 0) {
          const opt = el.castSlotLevel.selectedOptions && el.castSlotLevel.selectedOptions[0] ? el.castSlotLevel.selectedOptions[0] : null;
          if (!opt) { setCastStatus("Select a slot.", "error"); return; }
          const bucket = opt.dataset.bucket || "";
          const levelKey = opt.dataset.levelKey || "";
          const max = Math.max(0, nint(opt.dataset.max, 0));
          const used = getUsedSlots(bucket, levelKey);
          if (used >= max) { setCastStatus("No slots remaining at that level.", "error"); return; }
          setUsedSlots(bucket, levelKey, used + 1);
        }

        saveState();
        render();
        setCastStatus("Cast recorded. (Action economy and slots updated.)", "ok");
      }

      /* ---------- Spellbook (manage prepared/known) ---------- */
      function currentPrimaryBlock() {
        // Spellbook manages the "main" block by default, unless multiclass and user toggles via dropdown.
        // For simplicity, manage main if exists, else first active.
        return getActiveBlocks()[0];
      }

      function renderSpellbook() {
        setSpellbookStatus("");
        el.spellbookList.innerHTML = "";
        el.spellbookRightList.innerHTML = "";

        const blocks = getActiveBlocks();
        const first = blocks[0];
        const classKey = state.classBlocks[first.idx].key;

        if (!classKey) {
          const d = document.createElement("div");
          d.className = "sub";
          d.textContent = "Select a class to view spells.";
          el.spellbookList.appendChild(d);
          return;
        }

        const cd = getClassDef(classKey);
        if (!cd) {
          const d = document.createElement("div");
          d.className = "sub";
          d.textContent = "Class not found in spellcasting.json.";
          el.spellbookList.appendChild(d);
          return;
        }

        const mode = isPreparedCaster(cd) ? "prepared" : "known";
        const classLevel = state.classBlocks[first.idx].classLevel;
        const mod = state.classBlocks[first.idx].mod;

        // Title and instructions
        if (isPreparedCaster(cd)) {
          const limit = computePreparedLimit(cd, classLevel, mod);
          el.spellbookMainTitle.textContent = `Class Spells (Prepare up to ${limit})`;
          el.spellbookRightTitle.textContent = "Package (Subclass) Spells (Granted)";
        } else {
          const limit = computeKnownLimit(cd, classLevel);
          el.spellbookMainTitle.textContent = (limit > 0) ? `Class Spells (Known up to ${limit})` : "Class Spells (Known)";
          el.spellbookRightTitle.textContent = "Package (Subclass) Spells (Granted)";
        }

        const search = String(el.spellSearch.value || "").trim().toLowerCase();
        const lvFilter = String(el.spellLevelFilter.value || "all");

        const classSpellIds = getClassSpellIdsForClassKey(classKey);
        const grantedIds = getGrantedSpellIdsForClassKey(classKey);

        const picked = getBlockSpellPickList(first.key, mode);
        const pickedSet = new Set(picked);

        function spellMatches(id) {
          const s = getSpellDef(id);
          const name = (s && s.name) ? s.name.toLowerCase() : id.toLowerCase();
          if (search && !name.includes(search)) return false;

          if (lvFilter !== "all") {
            const lv = s ? Number(s.level) : NaN;
            if (!Number.isFinite(lv)) return false;
            if (String(lv) !== lvFilter) return false;
          }
          return true;
        }

        // Left side: class spells selectable (prepared/known)
        for (const sid of classSpellIds) {
          if (!spellMatches(sid)) continue;
          const s = getSpellDef(sid);
          const name = s ? (s.name || sid) : sid;
          const lv = s ? Number(s.level) : NaN;

          const b = document.createElement("button");
          b.className = "btn";
          b.type = "button";

          const isPicked = pickedSet.has(sid);
          b.textContent = isPicked ? `✓ ${name}` : name;

          b.addEventListener("click", () => {
            const now = getBlockSpellPickList(first.key, mode);
            const set = new Set(now);

            if (set.has(sid)) set.delete(sid);
            else {
              // enforce limit if present
              if (isPreparedCaster(cd)) {
                const limit = computePreparedLimit(cd, classLevel, mod);
                if (set.size >= limit) { setSpellbookStatus(`Prepared limit reached (${limit}).`, "error"); return; }
              } else {
                const limit = computeKnownLimit(cd, classLevel);
                if (limit > 0 && set.size >= limit) { setSpellbookStatus(`Known limit reached (${limit}).`, "error"); return; }
              }
              set.add(sid);
            }

            setBlockSpellPickList(first.key, mode, Array.from(set));
            saveState();
            render();
            renderSpellbook();
          });

          const q = document.createElement("button");
          q.className = "qBtn";
          q.type = "button";
          q.textContent = "?";
          q.addEventListener("click", () => {
            const sp = getSpellDef(sid);
            if (!sp) { openDialog(name, "Spell definition not found in spells.json.", ""); return; }
            const details = formatSpellDetails(sp);
            const split = splitHigherLevels(sp);
            const fullText = [
              split.base || "",
              split.higher ? ("\nAt Higher Levels:\n" + split.higher) : ""
            ].join("").trim();
            openDialog(sp.name || sid, fullText || "(No text)", details);
          });

          el.spellbookList.appendChild(b);
          el.spellbookList.appendChild(q);
        }

        // Right side: granted spells only (not selectable, but show info and allow cast by just existing in spells section)
        for (const sid of grantedIds) {
          if (!spellMatches(sid)) continue;
          const s = getSpellDef(sid);
          const name = s ? (s.name || sid) : sid;

          const b = document.createElement("button");
          b.className = "btn";
          b.type = "button";
          b.textContent = name;
          b.addEventListener("click", async () => {
            // granted spells are castable via spells section automatically.
            // Here, show info quickly.
            const sp = getSpellDef(sid);
            if (!sp) { setSpellbookStatus("Missing spell definition.", "error"); return; }
            const details = formatSpellDetails(sp);
            const split = splitHigherLevels(sp);
            const fullText = [
              split.base || "",
              split.higher ? ("\nAt Higher Levels:\n" + split.higher) : ""
            ].join("").trim();
            openDialog(sp.name || sid, fullText || "(No text)", details);
          });

          const q = document.createElement("button");
          q.className = "qBtn";
          q.type = "button";
          q.textContent = "?";
          q.addEventListener("click", () => {
            const sp = getSpellDef(sid);
            if (!sp) { openDialog(name, "Spell definition not found in spells.json.", ""); return; }
            const details = formatSpellDetails(sp);
            const split = splitHigherLevels(sp);
            const fullText = [
              split.base || "",
              split.higher ? ("\nAt Higher Levels:\n" + split.higher) : ""
            ].join("").trim();
            openDialog(sp.name || sid, fullText || "(No text)", details);
          });

          el.spellbookRightList.appendChild(b);
          el.spellbookRightList.appendChild(q);
        }
      }

      async function openSpellbook() {
        const ok = await loadSpellsIfNeeded();
        if (!ok) return;
        renderSpellbook();
        if (typeof el.spellbookDialog.showModal === "function") el.spellbookDialog.showModal();
        else alert("Spellbook dialog not supported in this browser.");
      }

      /* ---------- Abilities (packages) ---------- */
      function isLockedByRest(ability) {
        if (!ability || !ability.id) return false;
        if (!ability.usage || !ability.usage.type) return false;
        return !!state.restLocks[ability.id];
      }

      function markUsedByRest(ability) {
        if (!ability || !ability.id) return;
        if (!ability.usage || !ability.usage.type) return;
        if (ability.usage.type === "oncePerShortRest" || ability.usage.type === "oncePerLongRest") {
          state.restLocks[ability.id] = true;
        }
      }

      function canUseAbility(ability) {
        if (!ability) return false;
        if (state.level < (ability.level || 1)) return false;

        const actionType = ability.actionType || "action";
        if (actionType === "action" && state.actionUsed) return false;
        if (actionType === "bonus" && state.bonusUsed) return false;
        if (actionType === "reaction" && state.reactionUsed) return false;

        if (isLockedByRest(ability)) return false;
        return true;
      }

      async function handleAbilityUse(ability) {
        const actionType = ability.actionType || "action";
        if (actionType !== "passive") {
          if (!consumeEconomy(actionType)) {
            setStatus(`${actionTypeLabel(actionType)} already used this turn.`, "error");
            saveState();
            render();
            return;
          }
        }

        markUsedByRest(ability);
        saveState();
        render();
        setStatus(`${ability.name} used.`, "ok");
      }

      function abilityMetaLine(ability) {
        const parts = [];
        parts.push(actionTypeLabel(ability.actionType || "action"));

        if (ability.cost && ability.cost.length) {
          const costParts = ability.cost.map(c => `${c.amount} ${c.resource}`).join(", ");
          parts.push(`Cost: ${costParts}`);
        } else {
          parts.push("Cost: none");
        }

        if (ability.usage && ability.usage.type) {
          if (ability.usage.type === "oncePerShortRest") parts.push("Once per short rest");
          if (ability.usage.type === "oncePerLongRest") parts.push("Once per long rest");
          if (ability.usage.type === "charges") parts.push(`Charges: ${ability.usage.max}`);
        }

        return parts.join(" | ");
      }

      function renderAbilityCard(container, ability, { showUseButton }) {
        const base = getIconsBase();

        const card = document.createElement("div");
        card.className = "abilityCard";

        const actWrap = document.createElement("div");
        actWrap.className = "abilityActIcon";
        const actImg = document.createElement("img");
        actImg.alt = `${ability.actionType || "action"} icon`;
        const A = getActionIcons();
        const at = (ability.actionType || "action");
        const iconFile = at === "bonus" ? A.bonus : (at === "reaction" ? A.reaction : A.action);
        actImg.src = base + iconFile;
        actWrap.appendChild(actImg);

        const iconWrap = document.createElement("div");
        iconWrap.className = "abilityIcon";

        if (ability.icon && typeof ability.icon === "string") {
          const img = document.createElement("img");
          img.alt = `${ability.name} icon`;
          img.onerror = () => { iconWrap.innerHTML = `<div class="missingIcon">Missing icon<br>${ability.icon}</div>`; };
          img.src = ability.icon.startsWith("./") || ability.icon.startsWith("http")
            ? ability.icon
            : (base + ability.icon);
          iconWrap.appendChild(img);
        } else {
          iconWrap.innerHTML = `<div class="missingIcon">No icon</div>`;
        }

        const mid = document.createElement("div");
        const name = document.createElement("div");
        name.className = "abilityName";
        name.textContent = ability.name;

        const meta = document.createElement("div");
        meta.className = "abilityMeta";
        meta.textContent = abilityMetaLine(ability);

        mid.appendChild(name);
        mid.appendChild(meta);

        const btns = document.createElement("div");
        btns.className = "abilityBtns";

        if (showUseButton) {
          const useBtn = document.createElement("button");
          useBtn.className = "btn";
          useBtn.type = "button";
          useBtn.textContent = isLockedByRest(ability) ? "Locked" : "Use";
          useBtn.disabled = !canUseAbility(ability);
          useBtn.addEventListener("click", () => handleAbilityUse(ability));
          btns.appendChild(useBtn);
        }

        const q = document.createElement("button");
        q.className = "qBtn";
        q.type = "button";
        q.textContent = "?";
        q.addEventListener("click", () => {
          openDialog(ability.name, ability.desc || "", abilityMetaLine(ability));
        });
        btns.appendChild(q);

        card.appendChild(actWrap);
        card.appendChild(iconWrap);
        card.appendChild(mid);
        card.appendChild(btns);

        container.appendChild(card);
      }

      function renderAbilities() {
        el.abilitiesGrid.innerHTML = "";
        el.passivesGrid.innerHTML = "";

        const abilities = Array.isArray(MERGED_SUPPORT.abilities) ? MERGED_SUPPORT.abilities : [];
        const passives = Array.isArray(MERGED_SUPPORT.passiveAbilities) ? MERGED_SUPPORT.passiveAbilities : [];

        const unlockedA = abilities.filter(a => state.level >= (a.level || 1));
        const unlockedP = passives.filter(a => state.level >= (a.level || 1));

        if (unlockedA.length === 0) {
          const e = document.createElement("div");
          e.className = "sub";
          e.textContent = "No abilities loaded.";
          el.abilitiesGrid.appendChild(e);
        } else {
          for (const a of unlockedA) renderAbilityCard(el.abilitiesGrid, a, { showUseButton: true });
        }

        if (unlockedP.length === 0) {
          const e = document.createElement("div");
          e.className = "sub";
          e.textContent = "No passive abilities loaded.";
          el.passivesGrid.appendChild(e);
        } else {
          for (const a of unlockedP) renderAbilityCard(el.passivesGrid, a, { showUseButton: false });
        }
      }

      /* ---------- Render basics ---------- */
      function renderCoreStats() {
        el.statAText.textContent = String(state.statA);
        el.statBText.textContent = String(state.statB);
        el.statCText.textContent = String(state.statC);
      }

      function renderCombat() {
        el.hpNowText.textContent = String(state.hpNow);
        el.hpMaxText.textContent = String(state.hpMax);
        el.hpTempText.textContent = String(state.hpTemp);
        el.acText.textContent = String(state.acBase);

        el.hpMaxInput.value = String(state.hpMax);
        el.hpTempInput.value = String(state.hpTemp);
        el.acInput.value = String(state.acBase);
      }

      function updateEconomyIcons() {
        const base = getIconsBase();
        const A = getActionIcons();
        el.iconAction.src = base + (state.actionUsed ? A.actionUsed : A.action);
        el.iconBonus.src = base + (state.bonusUsed ? A.bonusUsed : A.bonus);
        el.iconReaction.src = base + (state.reactionUsed ? A.reactionUsed : A.reaction);
      }

      function renderEconomyButtons() {
        const maxAttacks = getMaxAttacksPerTurn();
        el.basicAttack.disabled = state.actionUsed || (state.attacksUsed >= maxAttacks);
        el.actionOptions.disabled = state.actionUsed;
        el.offhandAttack.disabled = state.bonusUsed;
        el.bonusOptions.disabled = state.bonusUsed;
        el.oppAttack.disabled = state.reactionUsed;
        el.readiedAttack.disabled = state.reactionUsed;
        el.reactionOptions.disabled = state.reactionUsed;
      }

      /* ---------- Class UI ---------- */
      function getClassKeys() {
        if (!SPELLCASTING || !SPELLCASTING.classes) return [];
        const keys = Object.keys(SPELLCASTING.classes);
        keys.sort((a,b)=>a.localeCompare(b));
        return keys;
      }

      function renderClassBlocksUI() {
        el.classBlocks.innerHTML = "";
        const keys = getClassKeys();

        function buildBlock(idx, title) {
          const wrap = document.createElement("div");

          const row = document.createElement("div");
          row.className = "classBlockRow";

          const col1 = document.createElement("div");
          const lab1 = document.createElement("div");
          lab1.className = "label";
          lab1.textContent = `${title} Class`;
          const sel = document.createElement("select");
          sel.id = `classSel_${idx}`;
          const opt0 = document.createElement("option");
          opt0.value = "";
          opt0.textContent = "-- Select --";
          sel.appendChild(opt0);
          for (const k of keys) {
            const o = document.createElement("option");
            o.value = k;
            o.textContent = k;
            sel.appendChild(o);
          }
          sel.value = state.classBlocks[idx].key || "";
          col1.appendChild(lab1);
          col1.appendChild(sel);

          const col2 = document.createElement("div");
          const lab2 = document.createElement("div");
          lab2.className = "label";
          lab2.textContent = "Class Level";
          const inpLvl = document.createElement("input");
          inpLvl.type = "number";
          inpLvl.min = "0";
          inpLvl.step = "1";
          inpLvl.id = `classLvl_${idx}`;
          inpLvl.value = String(state.classBlocks[idx].classLevel || 0);
          col2.appendChild(lab2);
          col2.appendChild(inpLvl);

          const col3 = document.createElement("div");
          const cd = getClassDef(state.classBlocks[idx].key);
          const abil = cd ? spellAbilityLabelForClass(cd) : "Mod";
          const lab3 = document.createElement("div");
          lab3.className = "label";
          lab3.id = `classModLabel_${idx}`;
          lab3.textContent = `${abil} Modifier`;
          const inpMod = document.createElement("input");
          inpMod.type = "number";
          inpMod.step = "1";
          inpMod.id = `classMod_${idx}`;
          inpMod.value = String(state.classBlocks[idx].mod || 0);
          col3.appendChild(lab3);
          col3.appendChild(inpMod);

          row.appendChild(col1);
          row.appendChild(col2);
          row.appendChild(col3);

          wrap.appendChild(row);

          // Packages for this class block
          const pkgRow = document.createElement("div");
          pkgRow.className = "controls";
          pkgRow.style.marginTop = "10px";

          const pkgInput = document.createElement("input");
          pkgInput.type = "url";
          pkgInput.placeholder = "Add package URL for this class (optional)";
          pkgInput.style.flex = "1";
          pkgInput.id = `classPkgUrl_${idx}`;

          const pkgBtn = document.createElement("button");
          pkgBtn.className = "btn";
          pkgBtn.type = "button";
          pkgBtn.textContent = "Add Class Package";
          pkgBtn.addEventListener("click", async () => {
            const u = String(pkgInput.value || "").trim();
            if (!u) return;
            state.classBlocks[idx].packages = Array.isArray(state.classBlocks[idx].packages) ? state.classBlocks[idx].packages : [];
            state.classBlocks[idx].packages.push(u);
            pkgInput.value = "";
            saveState();
            await loadPackages();
            await render();
          });

          const pkgClear = document.createElement("button");
          pkgClear.className = "btn";
          pkgClear.type = "button";
          pkgClear.textContent = "Clear Class Packages";
          pkgClear.addEventListener("click", async () => {
            state.classBlocks[idx].packages = [];
            saveState();
            await loadPackages();
            await render();
          });

          const pkgCount = document.createElement("div");
          pkgCount.className = "sub";
          pkgCount.textContent = `Class packages: ${(state.classBlocks[idx].packages || []).length}`;

          pkgRow.appendChild(pkgInput);
          pkgRow.appendChild(pkgBtn);
          pkgRow.appendChild(pkgClear);
          pkgRow.appendChild(pkgCount);

          wrap.appendChild(pkgRow);

          // Events
          sel.addEventListener("change", async () => {
            state.classBlocks[idx].key = String(sel.value || "");
            const newCd = getClassDef(state.classBlocks[idx].key);
            const lab = document.getElementById(`classModLabel_${idx}`);
            if (lab) lab.textContent = `${newCd ? spellAbilityLabelForClass(newCd) : "Mod"} Modifier`;

            // Reset spell picks for this block when class changes
            if (idx === 0) {
              delete state.preparedSpellsByBlock["main"];
              delete state.knownSpellsByBlock["main"];
            } else {
              delete state.preparedSpellsByBlock["mc1"];
              delete state.knownSpellsByBlock["mc1"];
            }

            saveState();
            await loadPackages();
            await render();
          });

          inpLvl.addEventListener("input", async () => {
            state.classBlocks[idx].classLevel = Math.max(0, nint(inpLvl.value, 0));
            saveState();
            await render();
          });

          inpMod.addEventListener("input", async () => {
            state.classBlocks[idx].mod = nint(inpMod.value, 0);
            saveState();
            await render();
          });

          return wrap;
        }

        el.classBlocks.appendChild(buildBlock(0, "Primary"));

        if (state.multiclass) {
          el.classBlocks.appendChild(buildBlock(1, "Secondary"));
        }
      }

      /* ---------- Manifest and packages ---------- */
      async function loadManifest() {
        const url = String(el.buildManifestUrl.value || "").trim();
        if (!url) { setStatus("Enter a manifest URL.", "error"); return; }

        try {
          const m = await fetchJson(url);

          if (m && typeof m === "object") {
            if (m.characterLevel != null) state.level = clamp(nint(m.characterLevel, state.level), 1, 20);

            if (m.multiclass != null) state.multiclass = !!m.multiclass;

            if (Array.isArray(m.classes)) {
              // classes: [{ key, level, mod, packages }]
              for (let i = 0; i < 2; i++) {
                const c = m.classes[i];
                if (!c) continue;
                if (typeof c.key === "string") state.classBlocks[i].key = c.key;
                if (c.level != null) state.classBlocks[i].classLevel = Math.max(0, nint(c.level, state.classBlocks[i].classLevel));
                if (c.mod !=null) state.classBlocks[i].mod = nint(c.mod, state.classBlocks[i].mod);
                if (Array.isArray(c.packages)) state.classBlocks[i].packages = c.packages.filter(x => typeof x === "string");
              }
            }

            if (Array.isArray(m.packages)) {
              state.packageUrls = m.packages.filter(x => typeof x === "string");
            }

            saveState();
            await loadPackages();
            await render();
            setStatus("Manifest loaded.", "ok");
          } else {
            setStatus("Manifest JSON invalid.", "error");
          }
        } catch (e) {
          setStatus("Failed to load manifest URL.", "error");
        }
      }

      function addGlobalPackage() {
        const u = prompt("Paste a package JSON URL to add (global):");
        if (!u) return;
        state.packageUrls.push(String(u).trim());
        saveState();
        loadPackages().then(render);
      }

      function clearGlobalPackages() {
        state.packageUrls = [];
        saveState();
        loadPackages().then(render);
      }

      function updatePackageSummary() {
        const globalCount = state.packageUrls.length;
        const c0 = (state.classBlocks[0].packages || []).length;
        const c1 = (state.classBlocks[1].packages || []).length;
        el.packageSummary.textContent = state.multiclass
          ? `Packages: global ${globalCount}, class1 ${c0}, class2 ${c1}`
          : `Packages: global ${globalCount}, class1 ${c0}`;
      }

      /* ---------- Calculator ---------- */
      function renderCalculator() {
        el.calcExpr.textContent = state.calcExpr || "";
        el.calcResult.textContent = state.calcResult || "0";
      }

      function sanitizeExpr(expr) {
        if (typeof expr !== "string") return "";
        return expr.replace(/[^0-9+\-*/().\s]/g, "");
      }

      function safeEval(expr) {
        const s = sanitizeExpr(expr).trim();
        if (!s) return { ok: true, value: 0, expr: "" };

        let bal = 0;
        for (const ch of s) {
          if (ch === "(") bal++;
          if (ch === ")") bal--;
          if (bal < 0) return { ok: false, error: "Mismatched parentheses." };
        }
        if (bal !== 0) return { ok: false, error: "Mismatched parentheses." };

        if (/[*\/+\-]{3,}/.test(s)) return { ok: false, error: "Invalid operator sequence." };

        try {
          const fn = new Function(`"use strict"; return (${s});`);
          const v = fn();
          if (!Number.isFinite(v)) return { ok: false, error: "Result is not a finite number." };
          return { ok: true, value: v, expr: s };
        } catch {
          return { ok: false, error: "Invalid expression." };
        }
      }

      function setCalcResultFromExpr() {
        const r = safeEval(state.calcExpr);
        if (!r.ok) {
          state.calcResult = "ERR";
          setCalcStatus(r.error, "error");
          renderCalculator();
          return;
        }
        state.calcResult = String(r.value);
        setCalcStatus("");
        renderCalculator();
      }

      function calcPress(key) {
        if (key === "C") {
          state.calcExpr = "";
          state.calcResult = "0";
          setCalcStatus("");
          saveState();
          renderCalculator();
          return;
        }
        if (key === "⌫") {
          state.calcExpr = (state.calcExpr || "").slice(0, -1);
          saveState();
          setCalcResultFromExpr();
          saveState();
          return;
        }
        if (key === "=") {
          const r = safeEval(state.calcExpr);
          if (!r.ok) {
            state.calcResult = "ERR";
            setCalcStatus(r.error, "error");
            saveState();
            renderCalculator();
            return;
          }
          state.calcExpr = String(r.value);
          state.calcResult = String(r.value);
          setCalcStatus("");
          saveState();
          renderCalculator();
          return;
        }

        state.calcExpr = sanitizeExpr((state.calcExpr || "") + key);
        saveState();
        setCalcResultFromExpr();
        saveState();
      }

      function getCalcNumericResult() {
        const r = safeEval(state.calcExpr);
        if (!r.ok) return { ok: false, error: r.error };
        return { ok: true, value: r.value };
      }

      /* ---------- Main render ---------- */
      async function render() {
        normalize();
        updatePackageSummary();
        renderResourcesFromPackages();
        renderClassBlocksUI();
        renderCoreStats();
        renderCombat();
        updateEconomyIcons();
        renderEconomyButtons();
        renderSpellSlots();
        renderSpellsSection();
        renderAbilities();
        renderCalculator();
        setCalcResultFromExpr();
      }

      function initDom() {
        el.levelInput = document.getElementById("levelInput");
        el.multiclassToggle = document.getElementById("multiclassToggle");
        el.classBlocks = document.getElementById("classBlocks");
        el.classWarning = document.getElementById("classWarning");

        el.buildManifestUrl = document.getElementById("buildManifestUrl");
        el.loadManifest = document.getElementById("loadManifest");
        el.addPackage = document.getElementById("addPackage");
        el.clearPackages = document.getElementById("clearPackages");
        el.packageSummary = document.getElementById("packageSummary");

        el.statALabel = document.getElementById("statALabel");
        el.statBLabel = document.getElementById("statBLabel");
        el.statCLabel = document.getElementById("statCLabel");

        el.statAText = document.getElementById("statAText");
        el.statBText = document.getElementById("statBText");
        el.statCText = document.getElementById("statCText");

        el.shortRest = document.getElementById("shortRest");
        el.longRest = document.getElementById("longRest");
        el.nextTurn = document.getElementById("nextTurn");
        el.openCalcTop = document.getElementById("openCalcTop");
        el.openSpellbookTop = document.getElementById("openSpellbookTop");

        el.spellMetaText = document.getElementById("spellMetaText");
        el.spellSlotsWrap = document.getElementById("spellSlotsWrap");
        el.spellsResetSlots = document.getElementById("spellsResetSlots");
        el.openSpellbookSlots = document.getElementById("openSpellbookSlots");
        el.spellStatus = document.getElementById("spellStatus");

        el.iconAction = document.getElementById("iconAction");
        el.iconBonus = document.getElementById("iconBonus");
        el.iconReaction = document.getElementById("iconReaction");

        el.basicAttack = document.getElementById("basicAttack");
        el.actionOptions = document.getElementById("actionOptions");
        el.offhandAttack = document.getElementById("offhandAttack");
        el.bonusOptions = document.getElementById("bonusOptions");
        el.oppAttack = document.getElementById("oppAttack");
        el.readiedAttack = document.getElementById("readiedAttack");
        el.readiedInfo = document.getElementById("readiedInfo");
        el.reactionOptions = document.getElementById("reactionOptions");

        el.statusBar = document.getElementById("statusBar");

        el.hpNowText = document.getElementById("hpNowText");
        el.hpMaxText = document.getElementById("hpMaxText");
        el.hpTempText = document.getElementById("hpTempText");
        el.acText = document.getElementById("acText");
        el.hpMaxInput = document.getElementById("hpMaxInput");
        el.hpTempInput = document.getElementById("hpTempInput");
        el.acInput = document.getElementById("acInput");
        el.hpFull = document.getElementById("hpFull");
        el.hpZeroTemp = document.getElementById("hpZeroTemp");
        el.openCalc = document.getElementById("openCalc");

        el.spellsSectionTitle = document.getElementById("spellsSectionTitle");
        el.spellsSectionSub = document.getElementById("spellsSectionSub");
        el.spellsManageBtn = document.getElementById("spellsManageBtn");
        el.spellsLimitText = document.getElementById("spellsLimitText");
        el.spellsGrid = document.getElementById("spellsGrid");
        el.spellsStatus = document.getElementById("spellsStatus");

        el.abilitiesGrid = document.getElementById("abilitiesGrid");
        el.passivesGrid = document.getElementById("passivesGrid");

        el.infoDialog = document.getElementById("infoDialog");
        el.dlgTitle = document.getElementById("dlgTitle");
        el.dlgDesc = document.getElementById("dlgDesc");
        el.dlgMeta = document.getElementById("dlgMeta");
        el.dlgClose = document.getElementById("dlgClose");
        el.dlgX = document.getElementById("dlgX");

        el.spellbookDialog = document.getElementById("spellbookDialog");
        el.spellbookTitle = document.getElementById("spellbookTitle");
        el.spellbookX = document.getElementById("spellbookX");
        el.spellbookClose = document.getElementById("spellbookClose");
        el.spellSearch = document.getElementById("spellSearch");
        el.spellLevelFilter = document.getElementById("spellLevelFilter");
        el.spellbookMainTitle = document.getElementById("spellbookMainTitle");
        el.spellbookRightTitle = document.getElementById("spellbookRightTitle");
        el.spellbookList = document.getElementById("spellbookList");
        el.spellbookRightList = document.getElementById("spellbookRightList");
        el.spellbookStatus = document.getElementById("spellbookStatus");

        el.castDialog = document.getElementById("castDialog");
        el.castTitle = document.getElementById("castTitle");
        el.castX = document.getElementById("castX");
        el.castClose = document.getElementById("castClose");
        el.castConfirm = document.getElementById("castConfirm");
        el.castSlotLevel = document.getElementById("castSlotLevel");
        el.castEconomy = document.getElementById("castEconomy");
        el.castDetailsText = document.getElementById("castDetailsText");
        el.castRulesText = document.getElementById("castRulesText");
        el.castHigherText = document.getElementById("castHigherText");
        el.castStatus = document.getElementById("castStatus");

        el.calcDialog = document.getElementById("calcDialog");
        el.calcExpr = document.getElementById("calcExpr");
        el.calcResult = document.getElementById("calcResult");
        el.calcStatus = document.getElementById("calcStatus");
        el.calcGrid = document.getElementById("calcGrid");
        el.applyAsDamage = document.getElementById("applyAsDamage");
        el.applyAsHeal = document.getElementById("applyAsHeal");
        el.calcCopy = document.getElementById("calcCopy");
        el.calcClose = document.getElementById("calcClose");
        el.calcX = document.getElementById("calcX");
      }

      async function init() {
        initDom();

        el.levelInput.value = String(state.level);
        el.multiclassToggle.checked = !!state.multiclass;
        el.buildManifestUrl.value = String(state.buildManifestUrl || "");

        el.levelInput.addEventListener("input", async () => {
          state.level = clamp(nint(el.levelInput.value, 1), 1, 20);
          saveState();
          setStatus("");
          await render();
        });

        el.multiclassToggle.addEventListener("change", async () => {
          state.multiclass = !!el.multiclassToggle.checked;
          if (!state.multiclass) {
            // keep primary level aligned with character level by default
            state.classBlocks[0].classLevel = state.level;
            state.classBlocks[1].classLevel = 0;
            state.classBlocks[1].key = "";
            state.classBlocks[1].packages = [];
            delete state.preparedSpellsByBlock["mc1"];
            delete state.knownSpellsByBlock["mc1"];
          }
          saveState();
          await loadPackages();
          await render();
        });

        el.loadManifest.addEventListener("click", async () => {
          state.buildManifestUrl = String(el.buildManifestUrl.value || "");
          saveState();
          await loadManifest();
        });

        el.addPackage.addEventListener("click", addGlobalPackage);
        el.clearPackages.addEventListener("click", clearGlobalPackages);

        el.shortRest.addEventListener("click", doShortRest);
        el.longRest.addEventListener("click", doLongRest);
        el.nextTurn.addEventListener("click", nextTurn);

        el.spellsResetSlots.addEventListener("click", async () => {
          resetAllSlots();
          await render();
          setSpellStatus("Spell slots reset.", "ok");
        });

        el.openSpellbookTop.addEventListener("click", openSpellbook);
        el.openSpellbookSlots.addEventListener("click", openSpellbook);
        el.spellsManageBtn.addEventListener("click", openSpellbook);

        el.basicAttack.addEventListener("click", async () => {
          normalize();
          const ok = useActionAttack();
          if (!ok) {
            setStatus("Action already used, or no attacks remaining this turn.", "error");
            await render();
            return;
          }
          saveState();
          await render();
          const maxAttacks = getMaxAttacksPerTurn();
          setStatus(`Basic Attack used (${state.attacksUsed}/${maxAttacks}).`, "ok");
        });

        // Options buttons are placeholders (kept from earlier UX)
        el.actionOptions.addEventListener("click", () => openDialog("Additional Options (Action)", GENERIC_ACTION_BUTTONS.map(x => `- ${x.label}: ${x.text}`).join("\n"), ""));
        el.bonusOptions.addEventListener("click", () => openDialog("Additional Options (Bonus Action)", "Use Offhand Attack or class features.", ""));
        el.reactionOptions.addEventListener("click", () => openDialog("Additional Options (Reaction)", "Use Attack of Opportunity, Readied Attack, or class features.", ""));

        el.offhandAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("bonus")) {
            setStatus("Bonus action already used this turn.", "error");
            await render();
            return;
          }
          saveState();
          await render();
          setStatus("Offhand Attack used (bonus action).", "ok");
        });

        el.oppAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("reaction")) {
            setStatus("Reaction already used this turn.", "error");
            await render();
            return;
          }
          saveState();
          await render();
          setStatus("Attack of Opportunity used (reaction).", "ok");
        });

        el.readiedAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("reaction")) {
            setStatus("Reaction already used this turn.", "error");
            await render();
            return;
          }
          saveState();
          await render();
          setStatus("Readied Attack used (reaction).", "ok");
        });

        el.readiedInfo.addEventListener("click", () => openDialog("Readied Attack", READIED_TEXT, ""));

        el.hpMaxInput.value = String(state.hpMax);
        el.hpTempInput.value = String(state.hpTemp);
        el.acInput.value = String(state.acBase);

        el.hpMaxInput.addEventListener("input", async () => {
          state.hpMax = Math.max(0, nint(el.hpMaxInput.value, 0));
          state.hpNow = clamp(state.hpNow, 0, state.hpMax);
          saveState();
          await render();
        });

        el.hpTempInput.addEventListener("input", async () => {
          state.hpTemp = Math.max(0, nint(el.hpTempInput.value, 0));
          saveState();
          await render();
        });

        el.acInput.addEventListener("input", async () => {
          state.acBase = Math.max(0, nint(el.acInput.value, 10));
          saveState();
          await render();
        });

        el.hpFull.addEventListener("click", async () => {
          normalize();
          state.hpNow = state.hpMax;
          saveState();
          await render();
          setStatus("Healed to full.", "ok");
        });

        el.hpZeroTemp.addEventListener("click", async () => {
          normalize();
          state.hpTemp = 0;
          saveState();
          await render();
          setStatus("Temp HP cleared.", "ok");
        });

        // Info dialog close
        el.dlgClose.addEventListener("click", () => el.infoDialog.close());
        el.dlgX.addEventListener("click", () => el.infoDialog.close());
        el.infoDialog.addEventListener("click", (e) => {
          const rect = el.infoDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.infoDialog.close();
        });

        // Spellbook dialog close
        el.spellbookClose.addEventListener("click", () => el.spellbookDialog.close());
        el.spellbookX.addEventListener("click", () => el.spellbookDialog.close());
        el.spellbookDialog.addEventListener("click", (e) => {
          const rect = el.spellbookDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.spellbookDialog.close();
        });

        el.spellSearch.addEventListener("input", () => { if (el.spellbookDialog.open) renderSpellbook(); });
        el.spellLevelFilter.addEventListener("change", () => { if (el.spellbookDialog.open) renderSpellbook(); });

        // Cast dialog close
        el.castClose.addEventListener("click", () => el.castDialog.close());
        el.castX.addEventListener("click", () => el.castDialog.close());
        el.castDialog.addEventListener("click", (e) => {
          const rect = el.castDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.castDialog.close();
        });
        el.castConfirm.addEventListener("click", castConfirm);

        // Calculator
        function openCalc() {
          if (typeof el.calcDialog.showModal === "function") el.calcDialog.showModal();
          else alert("Calculator dialog not supported in this browser.");
        }
        el.openCalc.addEventListener("click", openCalc);
        el.openCalcTop.addEventListener("click", openCalc);

        el.calcClose.addEventListener("click", () => el.calcDialog.close());
        el.calcX.addEventListener("click", () => el.calcDialog.close());
        el.calcDialog.addEventListener("click", (e) => {
          const rect = el.calcDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.calcDialog.close();
        });

        el.calcGrid.addEventListener("click", (e) => {
          const btn = e.target.closest("[data-k]");
          if (!btn) return;
          const k = String(btn.getAttribute("data-k") || "");
          if (!k) return;
          calcPress(k);
        });

        document.addEventListener("keydown", (e) => {
          if (!el.calcDialog.open) return;

          const k = e.key;
          const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
          if (tag === "input" || tag === "select" || tag === "textarea") return;

          if (k >= "0" && k <= "9") return calcPress(k);
          if (k === "+" || k === "-" || k === "*" || k === "/" || k === "." || k === "(" || k === ")") return calcPress(k);
          if (k === "Enter" || k === "=") { e.preventDefault(); return calcPress("="); }
          if (k === "Backspace") { e.preventDefault(); return calcPress("⌫"); }
          if (k === "Escape") { e.preventDefault(); return calcPress("C"); }
        });

        el.applyAsDamage.addEventListener("click", async () => {
          normalize();
          const r = getCalcNumericResult();
          if (!r.ok) { setCalcStatus(r.error, "error"); return; }
          const amt = Math.max(0, Number(r.value));
          const used = applyDamage(amt);
          saveState();
          await render();
          setCalcStatus(`Applied ${amt} damage (Temp used: ${used.usedTemp}, HP used: ${used.usedHp}).`, "ok");
        });

        el.applyAsHeal.addEventListener("click", async () => {
          normalize();
          const r = getCalcNumericResult();
          if (!r.ok) { setCalcStatus(r.error, "error"); return; }
          const amt = Math.max(0, Number(r.value));
          const healed = applyHeal(amt);
          saveState();
          await render();
          setCalcStatus(`Applied ${healed} healing (capped at Max HP).`, "ok");
        });

        el.calcCopy.addEventListener("click", async () => {
          try {
            await navigator.clipboard.writeText(String(el.calcResult.textContent || "0"));
            setCalcStatus("Result copied to clipboard.", "ok");
          } catch {
            setCalcStatus("Could not copy (browser blocked clipboard).", "error");
          }
        });

        // Initial load
        await loadSpellcasting();
        await loadPackages();
        updatePackageSummary();

        // Default: if not multiclass, keep primary class level equal to character level if it is 0
        if (!state.multiclass && nint(state.classBlocks[0].classLevel, 0) <= 0) state.classBlocks[0].classLevel = state.level;

        await render();
      }

      document.addEventListener("DOMContentLoaded", init);
    </script>
  </body>
</html>

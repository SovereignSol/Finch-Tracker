<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Generic RPG Tracker</title>

    <style>
      :root {
        --bg: #0b0f14;
        --text: #e9eef5;
        --muted: #97a6b8;
        --border: #223041;
        --btn: rgba(26, 39, 53, 0.9);
        --btnHover: rgba(34, 52, 71, 0.95);
        --danger: #ff6b6b;
        --ok: #7ce6a5;
      }

      * { box-sizing: border-box; }

      body {
        margin: 0;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
        background: var(--bg);
        color: var(--text);
        min-height: 100vh;
      }

      .wrap {
        max-width: 1100px;
        margin: 0 auto;
        padding: 22px 16px 56px;
      }

      .header h1 {
        margin: 0 0 6px;
        font-size: 28px;
        letter-spacing: 0.2px;
      }

      .sub { margin: 0; color: var(--muted); }

      .card {
        margin-top: 14px;
        padding: 14px;
        border-radius: 14px;
        border: 1px solid var(--border);
        background: rgba(18, 26, 35, 0.88);
        backdrop-filter: blur(2px);
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 220px;
        gap: 12px;
        align-items: center;
      }

      .label { color: var(--muted); font-size: 14px; }

      input[type="number"], input[type="text"], input[type="url"] {
        width: 100%;
        padding: 10px 10px;
        border-radius: 10px;
        border: 1px solid var(--border);
        background: rgba(15, 22, 32, 0.95);
        color: var(--text);
        outline: none;
      }

      select {
        width: 100%;
        padding: 10px 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(15, 22, 32, 0.95);
        color: var(--text);
        outline: none;
      }

      .topStats {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .topStats { grid-template-columns: 1fr 1fr 1fr; }
      }

      .statBox {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
      }
      .statLabel { font-size: 12px; color: var(--muted); display: flex; align-items: center; gap: 8px; }
      .statValue { margin-top: 4px; font-size: 18px; font-weight: 650; }

      .controls {
        margin-top: 12px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }

      .btn {
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: var(--btn);
        color: var(--text);
        cursor: pointer;
        user-select: none;
      }
      .btn:hover { background: var(--btnHover); }
      .btn:disabled { opacity: 0.45; cursor: not-allowed; }

      .qBtn {
        width: 40px;
        height: 40px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(0,0,0,0.12);
        color: var(--text);
        cursor: pointer;
        font-weight: 800;
      }
      .qBtn:hover { background: rgba(255,255,255,0.06); }

      .statusBar {
        margin-top: 10px;
        min-height: 18px;
        font-size: 13px;
        color: var(--muted);
        white-space: pre-wrap;
      }
      .statusBar.ok { color: var(--ok); }
      .statusBar.error { color: var(--danger); }

      .sectionTitle {
        display: flex;
        justify-content: space-between;
        align-items: baseline;
        gap: 12px;
      }
      .sectionTitle h2 { margin: 0; font-size: 18px; }

      /* Action Economy */
      .economyWrap {
        margin-top: 12px;
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }

      .econRow {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .econRow { grid-template-columns: 210px 1fr; align-items: center; }
      }

      .econLeft {
        display: flex;
        align-items: center;
        gap: 10px;
        color: var(--muted);
        font-size: 13px;
      }

      .econIcon {
        width: 44px;
        height: 44px;
        border-radius: 12px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(0,0,0,0.25);
        display: grid;
        place-items: center;
        flex: 0 0 auto;
      }
      .econIcon img {
        width: 44px;
        height: 44px;
        object-fit: cover;
        display: block;
      }

      .econBtns {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      /* Health + AC */
      .hpGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .hpGrid { grid-template-columns: 1fr 1fr 1fr 1fr; }
      }

      .hpControls {
        margin-top: 10px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 860px) {
        .hpControls { grid-template-columns: 1fr 1fr 1fr auto; align-items: end; }
      }

      /* Abilities */
      .abilityGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .abilityGrid { grid-template-columns: 1fr 1fr; }
      }

      .abilityCard {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: 56px 1fr auto;
        gap: 12px;
        align-items: center;
        position: relative;
        overflow: hidden;
      }

      .abilityActIcon {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 26px;
        height: 26px;
        border-radius: 8px;
        overflow: hidden;
        border: 1px solid rgba(255,255,255,0.06);
        background: rgba(0,0,0,0.25);
      }
      .abilityActIcon img {
        width: 26px;
        height: 26px;
        object-fit: cover;
        display: block;
      }

      .abilityIcon {
        width: 56px;
        height: 56px;
        border-radius: 14px;
        overflow: hidden;
        background: rgba(0,0,0,0.25);
        border: 1px solid rgba(255,255,255,0.06);
        display: grid;
        place-items: center;
      }
      .abilityIcon img {
        width: 56px;
        height: 56px;
        object-fit: cover;
        display: block;
      }

      .missingIcon {
        font-size: 11px;
        color: var(--muted);
        padding: 6px;
        text-align: center;
        line-height: 1.2;
      }

      .abilityName { font-weight: 700; letter-spacing: 0.2px; }
      .abilityMeta { margin-top: 4px; font-size: 13px; color: var(--muted); }
      .abilityBtns { display: flex; gap: 8px; align-items: center; }

      /* Spell slots UI */
      .slotRow {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(0,0,0,0.18);
        display: grid;
        grid-template-columns: 120px 1fr;
        gap: 10px;
        align-items: center;
        margin-top: 10px;
      }

      .slotLabel { color: var(--muted); font-size: 13px; }

      .slotBubbles {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
      }

      .slotBubble {
        width: 42px;
        height: 42px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: rgba(26, 39, 53, 0.85);
        color: var(--text);
        cursor: pointer;
        font-weight: 800;
        user-select: none;
      }

      .slotBubble.used {
        opacity: 0.35;
        text-decoration: line-through;
      }

      /* Prepared spells area */
      .spellPreparedGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: 1fr;
        gap: 8px;
      }
      @media (min-width: 900px) {
        .spellPreparedGrid { grid-template-columns: 1fr 1fr; }
      }

      .spellCard {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px;
        background: rgba(0,0,0,0.16);
        display: grid;
        grid-template-columns: 1fr auto;
        gap: 10px;
        align-items: center;
      }

      .spellName { font-weight: 750; }
      .spellMeta { margin-top: 4px; font-size: 12px; color: var(--muted); }
      .spellBtns { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }

      dialog {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 0;
        background: rgba(15, 22, 32, 0.98);
        color: var(--text);
        max-width: 900px;
        width: calc(100% - 24px);
      }
      dialog::backdrop { background: rgba(0,0,0,0.65); }

      .dlgHead {
        padding: 14px 14px 10px;
        border-bottom: 1px solid var(--border);
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        gap: 12px;
      }
      .dlgTitle { margin: 0; font-size: 18px; }

      .dlgBody { padding: 14px; }
      .dlgBody p { margin: 0 0 10px; line-height: 1.5; white-space: pre-wrap; }
      .dlgMeta { margin-top: 8px; color: var(--muted); font-size: 13px; }

      .dlgActions {
        padding: 12px 14px 14px;
        border-top: 1px solid var(--border);
        display: flex;
        justify-content: flex-end;
        gap: 10px;
      }

      .popupGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
      }
      @media (min-width: 900px) {
        .popupGrid { grid-template-columns: 1fr 1fr; }
      }

      .popupSection {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 12px;
        background: rgba(0,0,0,0.18);
      }
      .popupSectionTitle {
        margin: 0 0 10px;
        font-size: 14px;
        color: var(--muted);
      }

      .popupBtns { display: flex; gap: 10px; flex-wrap: wrap; }

      /* Calculator popup */
      .calcDisplayBox {
        border: 1px solid var(--border);
        border-radius: 14px;
        padding: 10px;
        background: rgba(15, 22, 32, 0.95);
      }
      .calcExpr {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 14px;
        color: var(--muted);
        min-height: 18px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .calcResult {
        margin-top: 6px;
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        font-size: 22px;
        font-weight: 800;
        color: var(--text);
        white-space: pre-wrap;
        word-break: break-word;
      }
      .calcGrid {
        margin-top: 12px;
        display: grid;
        grid-template-columns: repeat(4, minmax(56px, 1fr));
        gap: 10px;
      }
      .calcKey {
        padding: 14px 10px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: rgba(26, 39, 53, 0.85);
        color: var(--text);
        cursor: pointer;
        font-weight: 750;
        text-align: center;
        user-select: none;
      }
      .calcKey:hover { background: var(--btnHover); }
      .calcKey.wide { grid-column: span 2; }
      .calcKey.danger { color: #fff; background: rgba(255, 107, 107, 0.25); }
      .calcKey.ok { color: #06120b; background: rgba(124, 230, 165, 0.95); border-color: rgba(124, 230, 165, 0.35); }
      .calcKey.ok:hover { filter: brightness(0.95); }

      .footer { margin-top: 16px; font-size: 13px; color: var(--muted); }
    </style>
  </head>

  <body>
    <main class="wrap">
      <header class="header">
        <h1>Generic RPG Tracker</h1>
        <p class="sub">Loads abilities from ./data/abilities.json, spellcasting from ./data/spellcasting.json, spells from ./data/spells.json</p>
      </header>

      <section class="card" id="coreCard" aria-label="Core">
        <div class="row">
          <label for="levelInput" class="label">Character Level (1 to 20)</label>
          <input id="levelInput" type="number" min="1" max="20" step="1" />
        </div>

        <div class="row" style="margin-top: 10px;">
          <label for="classSelect" class="label">Class (Spellcasting)</label>
          <select id="classSelect">
            <option value="">Loading classes...</option>
          </select>
        </div>

        <div class="row" style="margin-top: 10px;" id="spellModRow">
          <label for="spellModInput" class="label" id="spellModLabel">Spellcasting Ability Mod</label>
          <input id="spellModInput" type="number" step="1" />
        </div>

        <div class="topStats">
          <div class="statBox">
            <div class="statLabel">Resource A</div>
            <div class="statValue" id="statAText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Resource B</div>
            <div class="statValue" id="statBText">-</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Resource C</div>
            <div class="statValue" id="statCText">-</div>
          </div>
        </div>

        <div class="controls">
          <button id="shortRest" class="btn" type="button">Short Rest</button>
          <button id="longRest" class="btn" type="button">Long Rest</button>
          <button id="nextTurn" class="btn" type="button">Next Turn</button>
          <button id="openCalcTop" class="btn" type="button">Open Calculator</button>
          <button id="openSpellbookTop" class="btn" type="button">Open Spellbook</button>
        </div>

        <div class="card" style="margin-top: 12px;">
          <div class="sectionTitle">
            <h2>Spell Slots</h2>
            <div class="sub" id="spellMetaText"></div>
          </div>

          <div id="spellSlotsWrap"></div>

          <div class="controls" style="margin-top: 12px;">
            <button id="spellsResetSlots" class="btn" type="button">Reset Slots</button>
            <button id="spellsPrepareBtn" class="btn" type="button">Prepare Spells</button>
            <div class="sub" id="preparedLimitText" style="margin-left: auto;"></div>
          </div>

          <div id="spellStatus" class="statusBar" role="status" aria-live="polite"></div>

          <div class="sectionTitle" style="margin-top: 16px;">
            <h2>Prepared Spells</h2>
            <div class="sub" id="preparedHint">Prepared spells appear here and can be cast, consuming action economy and spell slots.</div>
          </div>
          <div id="preparedSpellsGrid" class="spellPreparedGrid"></div>
        </div>

        <div class="economyWrap" aria-label="Action economy">
          <div class="econRow">
            <div class="econLeft">
              <div class="econIcon"><img id="iconAction" alt="Action" /></div>
              <div>Action</div>
            </div>
            <div class="econBtns">
              <button id="basicAttack" class="btn" type="button">Basic Attack</button>
              <button id="actionOptions" class="btn" type="button">Additional Options</button>
            </div>
          </div>

          <div class="econRow">
            <div class="econLeft">
              <div class="econIcon"><img id="iconBonus" alt="Bonus action" /></div>
              <div>Bonus Action</div>
            </div>
            <div class="econBtns">
              <button id="offhandAttack" class="btn" type="button">Offhand Attack</button>
              <button id="bonusOptions" class="btn" type="button">Additional Options</button>
            </div>
          </div>

          <div class="econRow">
            <div class="econLeft">
              <div class="econIcon"><img id="iconReaction" alt="Reaction" /></div>
              <div>Reaction</div>
            </div>
            <div class="econBtns">
              <button id="oppAttack" class="btn" type="button">Attack of Opportunity</button>
              <button id="readiedAttack" class="btn" type="button">Readied Attack</button>
              <button id="readiedInfo" class="qBtn" type="button" aria-label="Readied action details">?</button>
              <button id="reactionOptions" class="btn" type="button">Additional Options</button>
            </div>
          </div>
        </div>

        <div id="statusBar" class="statusBar" role="status" aria-live="polite"></div>
      </section>

      <section class="card" id="combatCard" aria-label="Health and AC">
        <div class="sectionTitle">
          <h2>Health and AC</h2>
          <div class="sub"></div>
        </div>

        <div class="hpGrid">
          <div class="statBox">
            <div class="statLabel">Current HP</div>
            <div class="statValue" id="hpNowText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Max HP</div>
            <div class="statValue" id="hpMaxText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">Temp HP</div>
            <div class="statValue" id="hpTempText">0</div>
          </div>
          <div class="statBox">
            <div class="statLabel">AC</div>
            <div class="statValue" id="acText">10</div>
          </div>
        </div>

        <div class="hpControls">
          <div>
            <label class="label" for="hpMaxInput">Set Max HP</label>
            <input id="hpMaxInput" type="number" min="0" step="1" />
          </div>
          <div>
            <label class="label" for="hpTempInput">Set Temp HP</label>
            <input id="hpTempInput" type="number" min="0" step="1" />
          </div>
          <div>
            <label class="label" for="acInput">Set AC</label>
            <input id="acInput" type="number" min="0" step="1" />
          </div>
          <div class="controls" style="margin-top:0">
            <button id="hpFull" class="btn" type="button">Full Heal</button>
            <button id="hpZeroTemp" class="btn" type="button">Clear Temp</button>
            <button id="openCalc" class="btn" type="button">Open Calculator</button>
          </div>
        </div>
      </section>

      <section class="card" id="abilitiesCard" aria-label="Abilities">
        <div class="sectionTitle">
          <h2>Abilities</h2>
          <div class="sub">Loaded from support document, spend action economy when used.</div>
        </div>
        <div id="abilitiesGrid" class="abilityGrid"></div>
      </section>

      <section class="card" id="passivesCard" aria-label="Passive Abilities">
        <div class="sectionTitle">
          <h2>Passive Abilities</h2>
          <div class="sub">Loaded from support document, reference only.</div>
        </div>
        <div id="passivesGrid" class="abilityGrid"></div>
      </section>

      <footer class="footer">Saved in your browser (localStorage).</footer>

      <dialog id="infoDialog" aria-label="Info dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle" id="dlgTitle">Info</h3>
          <button class="qBtn" id="dlgX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <p id="dlgDesc"></p>
          <div class="dlgMeta" id="dlgMeta"></div>
        </div>
        <div class="dlgActions">
          <button class="btn" id="dlgClose" type="button">Close</button>
        </div>
      </dialog>

      <dialog id="optionsDialog" aria-label="Additional options dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle" id="optTitle">Additional Options</h3>
          <button class="qBtn" id="optX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <div class="popupGrid">
            <div class="popupSection" id="optSectionGeneric">
              <div class="popupSectionTitle" id="optGenericTitle">Generic</div>
              <div class="popupBtns" id="optGenericBtns"></div>
            </div>

            <div class="popupSection">
              <div class="popupSectionTitle">Abilities</div>
              <div class="popupBtns" id="optAbilityBtns"></div>
            </div>

            <div class="popupSection">
              <div class="popupSectionTitle">Passive Abilities</div>
              <div class="popupBtns" id="optPassiveBtns"></div>
            </div>
          </div>
          <div class="statusBar" id="optStatus" role="status" aria-live="polite"></div>
        </div>
        <div class="dlgActions">
          <button class="btn" id="optClose" type="button">Close</button>
        </div>
      </dialog>

      <dialog id="calcDialog" aria-label="Calculator dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle">Calculator</h3>
          <button class="qBtn" id="calcX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <div class="calcDisplayBox">
            <div class="calcExpr" id="calcExpr"></div>
            <div class="calcResult" id="calcResult">0</div>
          </div>

          <div class="controls" style="margin-top: 12px">
            <button id="applyAsDamage" class="btn" type="button">Apply Result as Damage</button>
            <button id="applyAsHeal" class="btn" type="button">Apply Result as Healing</button>
            <button id="calcCopy" class="btn" type="button">Copy Result</button>
          </div>

          <div class="calcGrid" id="calcGrid">
            <button class="calcKey danger" data-k="C" type="button">C</button>
            <button class="calcKey" data-k="(" type="button">(</button>
            <button class="calcKey" data-k=")" type="button">)</button>
            <button class="calcKey" data-k="⌫" type="button">⌫</button>

            <button class="calcKey" data-k="7" type="button">7</button>
            <button class="calcKey" data-k="8" type="button">8</button>
            <button class="calcKey" data-k="9" type="button">9</button>
            <button class="calcKey" data-k="/" type="button">÷</button>

            <button class="calcKey" data-k="4" type="button">4</button>
            <button class="calcKey" data-k="5" type="button">5</button>
            <button class="calcKey" data-k="6" type="button">6</button>
            <button class="calcKey" data-k="*" type="button">×</button>

            <button class="calcKey" data-k="1" type="button">1</button>
            <button class="calcKey" data-k="2" type="button">2</button>
            <button class="calcKey" data-k="3" type="button">3</button>
            <button class="calcKey" data-k="-" type="button">−</button>

            <button class="calcKey wide" data-k="0" type="button">0</button>
            <button class="calcKey" data-k="." type="button">.</button>
            <button class="calcKey" data-k="+" type="button">+</button>

            <button class="calcKey ok wide" data-k="=" type="button">=</button>
          </div>

          <div class="statusBar" id="calcStatus" role="status" aria-live="polite"></div>
        </div>
        <div class="dlgActions">
          <button class="btn" id="calcClose" type="button">Close</button>
        </div>
      </dialog>

      <dialog id="spellbookDialog" aria-label="Spellbook dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle" id="spellbookTitle">Spellbook</h3>
          <button class="qBtn" id="spellbookX" type="button" aria-label="Close dialog">×</button>
        </div>

        <div class="dlgBody">
          <div class="controls" style="margin-top: 0;">
            <input id="spellSearch" type="text" placeholder="Search spells..." />
            <select id="spellLevelFilter">
              <option value="all">All levels</option>
              <option value="0">Cantrips</option>
              <option value="1">Level 1</option>
              <option value="2">Level 2</option>
              <option value="3">Level 3</option>
              <option value="4">Level 4</option>
              <option value="5">Level 5</option>
              <option value="6">Level 6</option>
              <option value="7">Level 7</option>
              <option value="8">Level 8</option>
              <option value="9">Level 9</option>
            </select>
          </div>

          <div class="popupGrid" style="margin-top: 12px;">
            <div class="popupSection">
              <div class="popupSectionTitle" id="spellbookMainTitle">Spells</div>
              <div id="spellbookList" class="popupBtns"></div>
            </div>

            <div class="popupSection">
              <div class="popupSectionTitle">Always Available (No preparation required)</div>
              <div id="spellbookAlwaysList" class="popupBtns"></div>
            </div>
          </div>

          <div class="statusBar" id="spellbookStatus" role="status" aria-live="polite"></div>
        </div>

        <div class="dlgActions">
          <button class="btn" id="spellbookClose" type="button">Close</button>
        </div>
      </dialog>

      <dialog id="castDialog" aria-label="Cast spell dialog">
        <div class="dlgHead">
          <h3 class="dlgTitle" id="castTitle">Cast Spell</h3>
          <button class="qBtn" id="castX" type="button" aria-label="Close dialog">×</button>
        </div>
        <div class="dlgBody">
          <div class="row" style="grid-template-columns: 1fr 220px;">
            <label class="label" for="castSlotLevel">Spell Slot Level</label>
            <select id="castSlotLevel"></select>
          </div>

          <div class="row" style="margin-top: 10px; grid-template-columns: 1fr 220px;">
            <label class="label" for="castEconomy">Consumes</label>
            <select id="castEconomy">
              <option value="action">Action</option>
              <option value="bonus">Bonus Action</option>
              <option value="reaction">Reaction</option>
              <option value="none">No Action (reference)</option>
            </select>
          </div>

          <div class="statBox" style="margin-top: 12px;">
            <div class="statLabel">Spell Effect (base)</div>
            <div class="statValue" style="font-size: 13px; font-weight: 500; margin-top: 8px; white-space: pre-wrap;" id="castBaseText"></div>
          </div>

          <div class="statBox" style="margin-top: 10px;">
            <div class="statLabel">At Higher Levels</div>
            <div class="statValue" style="font-size: 13px; font-weight: 500; margin-top: 8px; white-space: pre-wrap;" id="castHigherText"></div>
          </div>

          <div class="statusBar" id="castStatus" role="status" aria-live="polite"></div>
        </div>
        <div class="dlgActions">
          <button class="btn" id="castConfirm" type="button">Cast</button>
          <button class="btn" id="castClose" type="button">Close</button>
        </div>
      </dialog>
    </main>

    <script>
      "use strict";

      const SUPPORT_DOC_URL = "./data/abilities.json";
      const SPELLCASTING_URL = "./data/spellcasting.json";
      const SPELLS_URL = "./data/spells.json";

      const DEFAULT_ICONS_BASE = "./Icons/";
      const DEFAULT_ACTION_ICONS = {
        action: "Action.webp",
        bonus: "Bonus_action.webp",
        reaction: "Reaction.webp",
        actionUsed: "Action_used.webp",
        bonusUsed: "Bonus_action_used.webp",
        reactionUsed: "Reaction_used.webp",
      };

      const STORAGE_KEY = "generic_tracker_state_v3";

      function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
      function nint(v, fallback = 0) {
        const x = Number(v);
        return Number.isFinite(x) ? Math.trunc(x) : fallback;
      }

      const READIED_TEXT =
`Readied action (Ready -> then react later)
- On your turn, you use your ACTION to Ready something instead of doing it now.
- You must pick:
  1) A clear trigger (example: “When the ogre steps through the doorway…”), and
  2) The exact response (example: “…I shoot it with my bow,” or “…I move behind the pillar.”).
- Before the start of your next turn, if the trigger happens, you can use your REACTION to perform the readied response.
- If the trigger never happens (or you choose not to react), the readied action is lost when your next turn starts.
- If you Ready a SPELL, you cast it on your turn and hold it (concentration required), then release it with your reaction when the trigger happens. If you don’t release it, the spell slot is still spent.`;

      const GENERIC_ACTION_BUTTONS = [
        { id: "dash", label: "Dash", text: "Dash (move extra up to your speed)" },
        { id: "disengage", label: "Disengage", text: "Disengage (no opportunity attacks from your movement this turn)" },
        { id: "dodge", label: "Dodge", text: "Dodge (attacks vs you have disadvantage, Dex saves have advantage)" },
        { id: "help", label: "Help", text: "Help (give an ally advantage or assist a task)" },
        { id: "hide", label: "Hide", text: "Hide (make a Stealth check to become hidden)" },
        { id: "ready", label: "Ready", text: "Ready (set a trigger, then use your reaction to act)" },
        { id: "search", label: "Search", text: "Search (make a check to find something)" },
        { id: "object", label: "Use an Object / Interact", text: "Use an Object / Interact (open a door, pull a lever, draw or stow an item, etc.)" },
        { id: "improv", label: "Improvised action", text: "Improvised actions (DM call): lift/push/drag, break/force open, swing on a rope, tip a statue, grab a ledge, etc." },
        { id: "throw", label: "Throw something", text: "Throw something (usually an improvised weapon or a thrown weapon, resolved as an attack)" },
      ];

      const el = {};
      let state = loadState();

      let SUPPORT = null;
      let SPELLCASTING = null;
      let SPELLS = null;

      let currentCastSpellId = null;

      function loadState() {
        try {
          const raw = localStorage.getItem(STORAGE_KEY);
          if (!raw) {
            return {
              level: 1,
              classKey: "",
              spellMod: 0,
              statA: 0,
              statB: "-",
              statC: "-",
              spellSlotsUsed: {},
              preparedSpells: {},
              actionUsed: false,
              bonusUsed: false,
              reactionUsed: false,
              attacksUsed: 0,
              hpNow: 10,
              hpMax: 10,
              hpTemp: 0,
              acBase: 10,
              restLocks: {},
              calcExpr: "",
              calcResult: "0",
            };
          }

          const p = JSON.parse(raw);
          return {
            level: clamp(nint(p.level, 1), 1, 20),
            classKey: typeof p.classKey === "string" ? p.classKey : "",
            spellMod: nint(p.spellMod, 0),

            statA: Number.isFinite(Number(p.statA)) ? Number(p.statA) : 0,
            statB: (p.statB ?? "-"),
            statC: (p.statC ?? "-"),

            spellSlotsUsed: (p.spellSlotsUsed && typeof p.spellSlotsUsed === "object") ? p.spellSlotsUsed : {},
            preparedSpells: (p.preparedSpells && typeof p.preparedSpells === "object") ? p.preparedSpells : {},

            actionUsed: !!p.actionUsed,
            bonusUsed: !!p.bonusUsed,
            reactionUsed: !!p.reactionUsed,
            attacksUsed: Math.max(0, nint(p.attacksUsed, 0)),

            hpNow: Math.max(0, nint(p.hpNow, 10)),
            hpMax: Math.max(0, nint(p.hpMax, 10)),
            hpTemp: Math.max(0, nint(p.hpTemp, 0)),
            acBase: Math.max(0, nint(p.acBase, 10)),

            restLocks: (p.restLocks && typeof p.restLocks === "object") ? p.restLocks : {},

            calcExpr: typeof p.calcExpr === "string" ? p.calcExpr : "",
            calcResult: typeof p.calcResult === "string" ? p.calcResult : "0",
          };
        } catch {
          return {
            level: 1,
            classKey: "",
            spellMod: 0,
            statA: 0,
            statB: "-",
            statC: "-",
            spellSlotsUsed: {},
            preparedSpells: {},
            actionUsed: false,
            bonusUsed: false,
            reactionUsed: false,
            attacksUsed: 0,
            hpNow: 10,
            hpMax: 10,
            hpTemp: 0,
            acBase: 10,
            restLocks: {},
            calcExpr: "",
            calcResult: "0",
          };
        }
      }

      function saveState(s) { localStorage.setItem(STORAGE_KEY, JSON.stringify(s)); }

      function normalize() {
        state.level = clamp(nint(state.level, 1), 1, 20);
        if (typeof state.classKey !== "string") state.classKey = "";
        state.spellMod = nint(state.spellMod, 0);

        state.hpMax = Math.max(0, nint(state.hpMax, 0));
        state.hpNow = clamp(nint(state.hpNow, 0), 0, state.hpMax);
        state.hpTemp = Math.max(0, nint(state.hpTemp, 0));
        state.acBase = Math.max(0, nint(state.acBase, 10));
        state.attacksUsed = Math.max(0, nint(state.attacksUsed, 0));

        if (typeof state.spellSlotsUsed !== "object" || !state.spellSlotsUsed) state.spellSlotsUsed = {};
        if (typeof state.preparedSpells !== "object" || !state.preparedSpells) state.preparedSpells = {};

        if (typeof state.restLocks !== "object" || !state.restLocks) state.restLocks = {};
        if (typeof state.calcExpr !== "string") state.calcExpr = "";
        if (typeof state.calcResult !== "string") state.calcResult = "0";
      }

      function setStatus(msg, kind = "") {
        el.statusBar.textContent = msg || "";
        el.statusBar.classList.remove("ok", "error");
        if (kind) el.statusBar.classList.add(kind);
      }
      function setOptStatus(msg, kind = "") {
        el.optStatus.textContent = msg || "";
        el.optStatus.classList.remove("ok", "error");
        if (kind) el.optStatus.classList.add(kind);
      }
      function setCalcStatus(msg, kind = "") {
        el.calcStatus.textContent = msg || "";
        el.calcStatus.classList.remove("ok", "error");
        if (kind) el.calcStatus.classList.add(kind);
      }
      function setSpellStatus(msg, kind = "") {
        el.spellStatus.textContent = msg || "";
        el.spellStatus.classList.remove("ok", "error");
        if (kind) el.spellStatus.classList.add(kind);
      }
      function setSpellbookStatus(msg, kind = "") {
        el.spellbookStatus.textContent = msg || "";
        el.spellbookStatus.classList.remove("ok", "error");
        if (kind) el.spellbookStatus.classList.add(kind);
      }
      function setCastStatus(msg, kind = "") {
        el.castStatus.textContent = msg || "";
        el.castStatus.classList.remove("ok", "error");
        if (kind) el.castStatus.classList.add(kind);
      }

      function openDialog(title, desc, meta) {
        el.dlgTitle.textContent = title;
        el.dlgDesc.textContent = desc;
        el.dlgMeta.textContent = meta || "";
        if (typeof el.infoDialog.showModal === "function") el.infoDialog.showModal();
        else alert(`${title}\n\n${desc}\n\n${meta || ""}`);
      }

      function actionTypeLabel(actionType) {
        if (actionType === "bonus") return "Bonus Action";
        if (actionType === "reaction") return "Reaction";
        if (actionType === "action") return "Action";
        return "Passive";
      }

      function getIconsBase() {
        return (SUPPORT && SUPPORT.meta && SUPPORT.meta.iconsBase) ? SUPPORT.meta.iconsBase : DEFAULT_ICONS_BASE;
      }

      function getActionIcons() {
        return (SUPPORT && SUPPORT.meta && SUPPORT.meta.actionIcons) ? SUPPORT.meta.actionIcons : DEFAULT_ACTION_ICONS;
      }

      function getMaxAttacksPerTurn() {
        const v = SUPPORT && SUPPORT.meta && Number.isFinite(Number(SUPPORT.meta.maxAttacksPerTurn))
          ? Number(SUPPORT.meta.maxAttacksPerTurn)
          : 1;
        return Math.max(1, Math.trunc(v));
      }

      function consumeEconomy(kind) {
        if (kind === "action") {
          if (state.actionUsed) return false;
          state.actionUsed = true;
          return true;
        }
        if (kind === "bonus") {
          if (state.bonusUsed) return false;
          state.bonusUsed = true;
          return true;
        }
        if (kind === "reaction") {
          if (state.reactionUsed) return false;
          state.reactionUsed = true;
          return true;
        }
        return true;
      }

      function useActionAttack() {
        const maxAttacks = getMaxAttacksPerTurn();
        if (state.attacksUsed >= maxAttacks) return false;
        state.actionUsed = true;
        state.attacksUsed += 1;
        return true;
      }

      function nextTurn() {
        state.actionUsed = false;
        state.bonusUsed = false;
        state.reactionUsed = false;
        state.attacksUsed = 0;
        saveState(state);
        render();
        setStatus("Next turn: action economy refreshed.", "ok");
      }

      function doShortRest() {
        if (SUPPORT) {
          for (const a of SUPPORT.abilities || []) {
            if (a && a.id && a.usage && a.usage.type === "oncePerShortRest") {
              delete state.restLocks[a.id];
            }
          }
        }

        const classDef = getSelectedClassDef();
        const prog = classDef ? getProgressionDef(classDef.progression) : null;
        if (prog && prog.pactMagicTable) {
          state.spellSlotsUsed["pact"] = 0;
        }

        saveState(state);
        render();
        setStatus("Short rest: short-rest locks cleared.", "ok");
      }

      function doLongRest() {
        if (SUPPORT) {
          for (const a of SUPPORT.abilities || []) {
            if (a && a.id && a.usage && (a.usage.type === "oncePerShortRest" || a.usage.type === "oncePerLongRest")) {
              delete state.restLocks[a.id];
            }
          }
        }

        state.spellSlotsUsed = {};
        saveState(state);
        render();
        setStatus("Long rest: long-rest locks cleared.", "ok");
      }

      function applyDamage(amount) {
        amount = Math.max(0, Number(amount) || 0);
        if (amount <= 0) return { usedTemp: 0, usedHp: 0 };
        const usedTemp = Math.min(state.hpTemp, amount);
        state.hpTemp -= usedTemp;
        const remaining = amount - usedTemp;
        const usedHp = Math.min(state.hpNow, remaining);
        state.hpNow -= usedHp;
        return { usedTemp, usedHp };
      }

      function applyHeal(amount) {
        amount = Math.max(0, Number(amount) || 0);
        if (amount <= 0) return 0;
        const before = state.hpNow;
        state.hpNow = Math.min(state.hpMax, state.hpNow + amount);
        return state.hpNow - before;
      }

      function renderCoreStats() {
        el.statAText.textContent = String(state.statA);
        el.statBText.textContent = String(state.statB);
        el.statCText.textContent = String(state.statC);
      }

      function renderCombat() {
        el.hpNowText.textContent = String(state.hpNow);
        el.hpMaxText.textContent = String(state.hpMax);
        el.hpTempText.textContent = String(state.hpTemp);
        el.acText.textContent = String(state.acBase);

        el.hpMaxInput.value = String(state.hpMax);
        el.hpTempInput.value = String(state.hpTemp);
        el.acInput.value = String(state.acBase);
      }

      function updateEconomyIcons() {
        const base = getIconsBase();
        const A = getActionIcons();
        el.iconAction.src = base + (state.actionUsed ? A.actionUsed : A.action);
        el.iconBonus.src = base + (state.bonusUsed ? A.bonusUsed : A.bonus);
        el.iconReaction.src = base + (state.reactionUsed ? A.reactionUsed : A.reaction);
      }

      function renderEconomyButtons() {
        const maxAttacks = getMaxAttacksPerTurn();
        el.basicAttack.disabled = state.attacksUsed >= maxAttacks;
        el.actionOptions.disabled = state.actionUsed;
        el.offhandAttack.disabled = state.bonusUsed;
        el.bonusOptions.disabled = state.bonusUsed;
        el.oppAttack.disabled = state.reactionUsed;
        el.readiedAttack.disabled = state.reactionUsed;
        el.reactionOptions.disabled = state.reactionUsed;
      }

      function isLockedByRest(ability) {
        if (!ability || !ability.id) return false;
        if (!ability.usage || !ability.usage.type) return false;
        return !!state.restLocks[ability.id];
      }

      function markUsedByRest(ability) {
        if (!ability || !ability.id) return;
        if (!ability.usage || !ability.usage.type) return;
        if (ability.usage.type === "oncePerShortRest" || ability.usage.type === "oncePerLongRest") {
          state.restLocks[ability.id] = true;
        }
      }

      function canUseAbility(ability) {
        if (!ability) return false;
        if (state.level < (ability.level || 1)) return false;

        const actionType = ability.actionType || "action";
        if (actionType === "action" && state.actionUsed) return false;
        if (actionType === "bonus" && state.bonusUsed) return false;
        if (actionType === "reaction" && state.reactionUsed) return false;

        if (isLockedByRest(ability)) return false;
        return true;
      }

      async function handleAbilityUse(ability, sink = "main") {
        const setSinkStatus = (msg, kind) => {
          if (sink === "options") setOptStatus(msg, kind);
          else setStatus(msg, kind);
        };

        const actionType = ability.actionType || "action";
        if (actionType !== "passive") {
          if (!consumeEconomy(actionType)) {
            setSinkStatus(`${actionTypeLabel(actionType)} already used this turn.`, "error");
            saveState(state);
            await render();
            return;
          }
        }

        markUsedByRest(ability);
        saveState(state);
        await render();
        setSinkStatus(`${ability.name} used.`, "ok");
      }

      function abilityMetaLine(ability) {
        const parts = [];
        parts.push(actionTypeLabel(ability.actionType || "action"));

        if (ability.cost && ability.cost.length) {
          const costParts = ability.cost.map(c => `${c.amount} ${c.resource}`).join(", ");
          parts.push(`Cost: ${costParts}`);
        } else {
          parts.push("Cost: none");
        }

        if (ability.usage && ability.usage.type) {
          if (ability.usage.type === "oncePerShortRest") parts.push("Once per short rest");
          if (ability.usage.type === "oncePerLongRest") parts.push("Once per long rest");
          if (ability.usage.type === "charges") parts.push(`Charges: ${ability.usage.max}`);
        }

        return parts.join(" | ");
      }

      function renderAbilityCard(container, ability, opts) {
        const base = getIconsBase();

        const card = document.createElement("div");
        card.className = "abilityCard";

        const actWrap = document.createElement("div");
        actWrap.className = "abilityActIcon";
        const actImg = document.createElement("img");
        actImg.alt = `${ability.actionType || "action"} icon`;
        const A = getActionIcons();
        const at = (ability.actionType || "action");
        const iconFile = at === "bonus" ? A.bonus : (at === "reaction" ? A.reaction : A.action);
        actImg.src = base + iconFile;
        actWrap.appendChild(actImg);

        const iconWrap = document.createElement("div");
        iconWrap.className = "abilityIcon";

        if (ability.icon && typeof ability.icon === "string") {
          const img = document.createElement("img");
          img.alt = `${ability.name} icon`;
          img.onerror = () => { iconWrap.innerHTML = `<div class="missingIcon">Missing icon<br>${ability.icon}</div>`; };
          img.src = ability.icon.startsWith("./") || ability.icon.startsWith("http")
            ? ability.icon
            : (base + ability.icon);
          iconWrap.appendChild(img);
        } else {
          iconWrap.innerHTML = `<div class="missingIcon">No icon</div>`;
        }

        const mid = document.createElement("div");
        const name = document.createElement("div");
        name.className = "abilityName";
        name.textContent = ability.name;

        const meta = document.createElement("div");
        meta.className = "abilityMeta";
        meta.textContent = abilityMetaLine(ability);

        mid.appendChild(name);
        mid.appendChild(meta);

        const btns = document.createElement("div");
        btns.className = "abilityBtns";

        if (opts && opts.showUseButton) {
          const useBtn = document.createElement("button");
          useBtn.className = "btn";
          useBtn.type = "button";
          useBtn.textContent = isLockedByRest(ability) ? "Locked" : "Use";
          useBtn.disabled = !canUseAbility(ability);
          useBtn.addEventListener("click", () => handleAbilityUse(ability, "main"));
          btns.appendChild(useBtn);
        }

        const q = document.createElement("button");
        q.className = "qBtn";
        q.type = "button";
        q.textContent = "?";
        q.addEventListener("click", () => {
          openDialog(ability.name, ability.desc || "", abilityMetaLine(ability));
        });
        btns.appendChild(q);

        card.appendChild(actWrap);
        card.appendChild(iconWrap);
        card.appendChild(mid);
        card.appendChild(btns);

        container.appendChild(card);
      }

      function renderAbilities() {
        el.abilitiesGrid.innerHTML = "";
        el.passivesGrid.innerHTML = "";

        if (!SUPPORT || !Array.isArray(SUPPORT.abilities)) {
          const e1 = document.createElement("div");
          e1.className = "sub";
          e1.textContent = "No abilities loaded.";
          el.abilitiesGrid.appendChild(e1);

          const e2 = document.createElement("div");
          e2.className = "sub";
          e2.textContent = "No passive abilities loaded.";
          el.passivesGrid.appendChild(e2);
          return;
        }

        const unlocked = SUPPORT.abilities.filter(a => state.level >= (a.level || 1));
        const active = unlocked.filter(a => Array.isArray(a.cost) && a.cost.length > 0);
        const passive = unlocked.filter(a => !Array.isArray(a.cost) || a.cost.length === 0);

        if (active.length === 0) {
          const e = document.createElement("div");
          e.className = "sub";
          e.textContent = "No abilities available yet.";
          el.abilitiesGrid.appendChild(e);
        } else {
          for (const a of active) renderAbilityCard(el.abilitiesGrid, a, { showUseButton: true });
        }

        if (passive.length === 0) {
          const e = document.createElement("div");
          e.className = "sub";
          e.textContent = "No passive abilities available yet.";
          el.passivesGrid.appendChild(e);
        } else {
          for (const a of passive) renderAbilityCard(el.passivesGrid, a, { showUseButton: false });
        }
      }

      function openOptions(kind) {
        el.optTitle.textContent = `Additional Options (${actionTypeLabel(kind)})`;
        setOptStatus("");

        el.optGenericBtns.innerHTML = "";
        el.optAbilityBtns.innerHTML = "";
        el.optPassiveBtns.innerHTML = "";

        if (kind === "action") {
          el.optSectionGeneric.style.display = "";
          el.optGenericTitle.textContent = "Generic actions";
          for (const g of GENERIC_ACTION_BUTTONS) {
            const b = document.createElement("button");
            b.className = "btn";
            b.type = "button";
            b.textContent = g.label;
            b.disabled = state.actionUsed;
            b.addEventListener("click", async () => {
              if (!consumeEconomy("action")) { setOptStatus("Action already used this turn.", "error"); return; }
              saveState(state);
              await render();
              setOptStatus(`Used action: ${g.text}`, "ok");
            });
            el.optGenericBtns.appendChild(b);
          }
        } else if (kind === "bonus") {
          el.optSectionGeneric.style.display = "";
          el.optGenericTitle.textContent = "Bonus actions";
          const b = document.createElement("button");
          b.className = "btn";
          b.type = "button";
          b.textContent = "Offhand Attack";
          b.disabled = state.bonusUsed;
          b.addEventListener("click", async () => {
            if (!consumeEconomy("bonus")) { setOptStatus("Bonus action already used this turn.", "error"); return; }
            saveState(state);
            await render();
            setOptStatus("Offhand Attack used (bonus action).", "ok");
          });
          el.optGenericBtns.appendChild(b);
        } else {
          el.optSectionGeneric.style.display = "";
          el.optGenericTitle.textContent = "Reactions";

          const b1 = document.createElement("button");
          b1.className = "btn";
          b1.type = "button";
          b1.textContent = "Attack of Opportunity";
          b1.disabled = state.reactionUsed;
          b1.addEventListener("click", async () => {
            if (!consumeEconomy("reaction")) { setOptStatus("Reaction already used this turn.", "error"); return; }
            saveState(state);
            await render();
            setOptStatus("Attack of Opportunity used (reaction).", "ok");
          });

          const b2 = document.createElement("button");
          b2.className = "btn";
          b2.type = "button";
          b2.textContent = "Readied Attack";
          b2.disabled = state.reactionUsed;
          b2.addEventListener("click", async () => {
            if (!consumeEconomy("reaction")) { setOptStatus("Reaction already used this turn.", "error"); return; }
            saveState(state);
            await render();
            setOptStatus("Readied Attack used (reaction).", "ok");
          });

          const q = document.createElement("button");
          q.className = "qBtn";
          q.type = "button";
          q.textContent = "?";
          q.addEventListener("click", () => openDialog("Readied Attack", READIED_TEXT, ""));

          el.optGenericBtns.appendChild(b1);
          el.optGenericBtns.appendChild(b2);
          el.optGenericBtns.appendChild(q);
        }

        const unlocked = (SUPPORT && Array.isArray(SUPPORT.abilities))
          ? SUPPORT.abilities.filter(a => state.level >= (a.level || 1))
          : [];

        const active = unlocked.filter(a => Array.isArray(a.cost) && a.cost.length > 0);
        const passive = unlocked.filter(a => !Array.isArray(a.cost) || a.cost.length === 0);

        const forKindActive = active.filter(a => (a.actionType || "action") === kind);
        const forKindPassive = passive.filter(a => (a.actionType || "passive") === kind);

        if (forKindActive.length === 0) {
          const sp = document.createElement("div");
          sp.className = "sub";
          sp.textContent = "No abilities for this action type.";
          el.optAbilityBtns.appendChild(sp);
        } else {
          for (const a of forKindActive) {
            const b = document.createElement("button");
            b.className = "btn";
            b.type = "button";
            b.textContent = a.name + (isLockedByRest(a) ? " (Locked)" : "");
            b.disabled = !canUseAbility(a);
            b.addEventListener("click", async () => {
              if (!canUseAbility(a)) { setOptStatus(`${a.name}: not available right now.`, "error"); await render(); return; }
              await handleAbilityUse(a, "options");
            });

            const q = document.createElement("button");
            q.className = "qBtn";
            q.type = "button";
            q.textContent = "?";
            q.addEventListener("click", () => openDialog(a.name, a.desc || "", abilityMetaLine(a)));

            el.optAbilityBtns.appendChild(b);
            el.optAbilityBtns.appendChild(q);
          }
        }

        if (forKindPassive.length === 0) {
          const sp = document.createElement("div");
          sp.className = "sub";
          sp.textContent = "No passive abilities for this action type.";
          el.optPassiveBtns.appendChild(sp);
        } else {
          for (const p of forKindPassive) {
            const canSpend =
              (p.actionType === "action" && !state.actionUsed) ||
              (p.actionType === "bonus" && !state.bonusUsed) ||
              (p.actionType === "reaction" && !state.reactionUsed);

            const b = document.createElement("button");
            b.className = "btn";
            b.type = "button";
            b.textContent = p.name;
            b.disabled = !canSpend;
            b.addEventListener("click", async () => {
              if (!consumeEconomy(p.actionType || "action")) { setOptStatus(`${actionTypeLabel(p.actionType)} already used this turn.`, "error"); return; }
              saveState(state);
              await render();
              setOptStatus(`Used ${actionTypeLabel(p.actionType)} for: ${p.name}`, "ok");
            });

            const q = document.createElement("button");
            q.className = "qBtn";
            q.type = "button";
            q.textContent = "?";
            q.addEventListener("click", () => openDialog(p.name, p.desc || "", abilityMetaLine(p)));

            el.optPassiveBtns.appendChild(b);
            el.optPassiveBtns.appendChild(q);
          }
        }

        if (typeof el.optionsDialog.showModal === "function") el.optionsDialog.showModal();
        else alert("Options dialog not supported in this browser.");
      }

      /* ---------- Calculator ---------- */
      function renderCalculator() {
        el.calcExpr.textContent = state.calcExpr || "";
        el.calcResult.textContent = state.calcResult || "0";
      }

      function sanitizeExpr(expr) {
        if (typeof expr !== "string") return "";
        return expr.replace(/[^0-9+\-*/().\s]/g, "");
      }

      function safeEval(expr) {
        const s = sanitizeExpr(expr).trim();
        if (!s) return { ok: true, value: 0, expr: "" };

        let bal = 0;
        for (const ch of s) {
          if (ch === "(") bal++;
          if (ch === ")") bal--;
          if (bal < 0) return { ok: false, error: "Mismatched parentheses." };
        }
        if (bal !== 0) return { ok: false, error: "Mismatched parentheses." };

        if (/[*\/+\-]{3,}/.test(s)) return { ok: false, error: "Invalid operator sequence." };

        try {
          const fn = new Function(`"use strict"; return (${s});`);
          const v = fn();
          if (!Number.isFinite(v)) return { ok: false, error: "Result is not a finite number." };
          return { ok: true, value: v, expr: s };
        } catch {
          return { ok: false, error: "Invalid expression." };
        }
      }

      function setCalcResultFromExpr() {
        const r = safeEval(state.calcExpr);
        if (!r.ok) {
          state.calcResult = "ERR";
          setCalcStatus(r.error, "error");
          renderCalculator();
          return;
        }
        state.calcResult = String(r.value);
        setCalcStatus("");
        renderCalculator();
      }

      function calcPress(key) {
        if (key === "C") {
          state.calcExpr = "";
          state.calcResult = "0";
          setCalcStatus("");
          saveState(state);
          renderCalculator();
          return;
        }
        if (key === "⌫") {
          state.calcExpr = (state.calcExpr || "").slice(0, -1);
          saveState(state);
          setCalcResultFromExpr();
          saveState(state);
          return;
        }
        if (key === "=") {
          const r = safeEval(state.calcExpr);
          if (!r.ok) {
            state.calcResult = "ERR";
            setCalcStatus(r.error, "error");
            saveState(state);
            renderCalculator();
            return;
          }
          state.calcExpr = String(r.value);
          state.calcResult = String(r.value);
          setCalcStatus("");
          saveState(state);
          renderCalculator();
          return;
        }

        state.calcExpr = sanitizeExpr((state.calcExpr || "") + key);
        saveState(state);
        setCalcResultFromExpr();
        saveState(state);
      }

      function getCalcNumericResult() {
        const r = safeEval(state.calcExpr);
        if (!r.ok) return { ok: false, error: r.error };
        return { ok: true, value: r.value };
      }

      /* ---------- Support doc loading ---------- */
      async function loadSupportDoc() {
        try {
          const res = await fetch(SUPPORT_DOC_URL, { cache: "no-store" });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          SUPPORT = await res.json();
          return true;
        } catch {
          SUPPORT = null;
          setStatus(`Failed to load support doc: ${SUPPORT_DOC_URL}\nTip: must be served over http(s).`, "error");
          return false;
        }
      }

      async function loadSpellcasting() {
        try {
          const res = await fetch(SPELLCASTING_URL, { cache: "no-store" });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          SPELLCASTING = await res.json();
          return true;
        } catch {
          SPELLCASTING = null;
          setSpellStatus(`Failed to load spellcasting: ${SPELLCASTING_URL}`, "error");
          return false;
        }
      }

      async function loadSpellsIfNeeded() {
        if (SPELLS) return true;
        try {
          const res = await fetch(SPELLS_URL, { cache: "no-store" });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          SPELLS = await res.json();
          return true;
        } catch {
          SPELLS = null;
          setSpellbookStatus(`Failed to load spells: ${SPELLS_URL}`, "error");
          return false;
        }
      }

      function rebuildClassSelect() {
        el.classSelect.innerHTML = "";
        const optNone = document.createElement("option");
        optNone.value = "";
        optNone.textContent = "None";
        el.classSelect.appendChild(optNone);

        if (!SPELLCASTING || !SPELLCASTING.classes) {
          const o = document.createElement("option");
          o.value = "";
          o.textContent = "Spellcasting not loaded";
          el.classSelect.appendChild(o);
          return;
        }

        const keys = Object.keys(SPELLCASTING.classes);
        keys.sort((a,b)=>a.localeCompare(b));

        for (const k of keys) {
          const c = SPELLCASTING.classes[k];
          const o = document.createElement("option");
          o.value = k;
          o.textContent = k;
          el.classSelect.appendChild(o);
        }

        el.classSelect.value = state.classKey || "";
      }

      function getSelectedClassDef() {
        if (!SPELLCASTING || !SPELLCASTING.classes) return null;
        const k = state.classKey || "";
        return (k && SPELLCASTING.classes[k]) ? SPELLCASTING.classes[k] : null;
      }

      function getProgressionDef(progKey) {
        if (!SPELLCASTING || !SPELLCASTING.progressions) return null;
        return (progKey && SPELLCASTING.progressions[progKey]) ? SPELLCASTING.progressions[progKey] : null;
      }

      function isPreparedCaster(classDef) {
        return !!(classDef && classDef.prepared && classDef.prepared.type === "prepared");
      }

      function inferAbilityFromPreparedRule(classDef) {
        if (!classDef || !classDef.prepared || !classDef.prepared.formula) return "";
        const f = String(classDef.prepared.formula || "").toUpperCase();
        if (f.includes("INT")) return "INT";
        if (f.includes("WIS")) return "WIS";
        if (f.includes("CHA")) return "CHA";
        return "";
      }

      function renderSpellModInput() {
        const classDef = getSelectedClassDef();
        if (!classDef) {
          el.spellModRow.style.display = "none";
          return;
        }

        const ab = inferAbilityFromPreparedRule(classDef) || "SPELL";
        el.spellModRow.style.display = "";
        el.spellModLabel.textContent = `Spellcasting Ability Mod (${ab})`;
        el.spellModInput.value = String(state.spellMod);
      }

      function computePreparedLimit(classDef) {
        if (!isPreparedCaster(classDef)) return 0;

        const mod = nint(state.spellMod, 0);
        const lvl = clamp(nint(state.level, 1), 1, 20);

        const f = String(classDef.prepared.formula || "").toUpperCase();
        let val = 0;

        if (f.includes("FLOOR") || f.includes("LEVEL/2")) {
          val = mod + Math.floor(lvl / 2);
        } else {
          val = mod + lvl;
        }

        const min = Number.isFinite(Number(classDef.prepared.min)) ? Number(classDef.prepared.min) : 1;
        return Math.max(min, Math.trunc(val));
      }

      function getSlotsForCurrent() {
        const classDef = getSelectedClassDef();
        if (!classDef) return { type: "none" };

        const prog = getProgressionDef(classDef.progression);
        if (!prog) return { type: "none" };

        const lvl = clamp(nint(state.level, 1), 1, 20);

        if (prog.pactMagicTable) {
          const row = prog.pactMagicTable[String(lvl)] || prog.pactMagicTable[lvl];
          const recharge = "shortRest";
          if (!row) return { type: "pact", slots: 0, slotLevel: 1, recharge };
          return {
            type: "pact",
            slots: Math.max(0, nint(row.slots, 0)),
            slotLevel: Math.max(1, nint(row.slotLevel, 1)),
            recharge
          };
        }

        const tbl = prog.slotTable;
        const arr = (tbl && (tbl[String(lvl)] || tbl[lvl])) ? (tbl[String(lvl)] || tbl[lvl]) : null;
        if (!arr || !Array.isArray(arr)) return { type: "standard", levels: [] };

        return { type: "standard", levels: arr.map(x => Math.max(0, nint(x, 0))) };
      }

      function getUsedSlots(levelKey) {
        const v = state.spellSlotsUsed[levelKey];
        return Math.max(0, nint(v, 0));
      }

      function setUsedSlots(levelKey, used) {
        state.spellSlotsUsed[levelKey] = Math.max(0, nint(used, 0));
      }

      function resetAllSlots() {
        state.spellSlotsUsed = {};
        saveState(state);
      }

      function renderSpellSlots() {
        const classDef = getSelectedClassDef();

        el.spellSlotsWrap.innerHTML = "";
        el.spellMetaText.textContent = "";
        el.preparedLimitText.textContent = "";
        el.spellsPrepareBtn.style.display = "none";

        if (!SPELLCASTING) {
          el.spellMetaText.textContent = "Spellcasting rules not loaded.";
          return;
        }

        if (!classDef) {
          el.spellMetaText.textContent = "Select a class to show spellcasting.";
          return;
        }

        const slots = getSlotsForCurrent();

        if (slots.type === "pact") {
          el.spellMetaText.textContent = `Pact Magic, Slot Level ${slots.slotLevel}, Recharge: short rest`;

          const row = document.createElement("div");
          row.className = "slotRow";

          const left = document.createElement("div");
          left.className = "slotLabel";
          left.textContent = `Pact Slots (L${slots.slotLevel})`;

          const right = document.createElement("div");
          right.className = "slotBubbles";

          const used = clamp(getUsedSlots("pact"), 0, slots.slots);
          if (used !== getUsedSlots("pact")) setUsedSlots("pact", used);

          for (let i = 0; i < slots.slots; i++) {
            const b = document.createElement("button");
            b.type = "button";
            b.className = "slotBubble" + (i < used ? " used" : "");
            b.textContent = "★";
            b.addEventListener("click", async () => {
              const nowUsed = getUsedSlots("pact");
              const nextUsed = (i < nowUsed) ? i : (i + 1);
              setUsedSlots("pact", clamp(nextUsed, 0, slots.slots));
              saveState(state);
              await render();
            });
            right.appendChild(b);
          }

          row.appendChild(left);
          row.appendChild(right);
          el.spellSlotsWrap.appendChild(row);
        } else {
          el.spellMetaText.textContent = `Progression: ${classDef.progression}`;

          const maxByLevel = slots.levels;
          for (let idx = 0; idx < maxByLevel.length; idx++) {
            const max = maxByLevel[idx];
            const spellLevel = idx + 1;
            if (max <= 0) continue;

            const levelKey = String(spellLevel);
            const used = clamp(getUsedSlots(levelKey), 0, max);
            if (used !== getUsedSlots(levelKey)) setUsedSlots(levelKey, used);

            const row = document.createElement("div");
            row.className = "slotRow";

            const left = document.createElement("div");
            left.className = "slotLabel";
            left.textContent = `Level ${spellLevel}`;

            const right = document.createElement("div");
            right.className = "slotBubbles";

            for (let i = 0; i < max; i++) {
              const b = document.createElement("button");
              b.type = "button";
              b.className = "slotBubble" + (i < used ? " used" : "");
              b.textContent = String(spellLevel);
              b.addEventListener("click", async () => {
                const nowUsed = getUsedSlots(levelKey);
                const nextUsed = (i < nowUsed) ? i : (i + 1);
                setUsedSlots(levelKey, clamp(nextUsed, 0, max));
                saveState(state);
                await render();
              });
              right.appendChild(b);
            }

            row.appendChild(left);
            row.appendChild(right);
            el.spellSlotsWrap.appendChild(row);
          }
        }

        if (isPreparedCaster(classDef)) {
          const limit = computePreparedLimit(classDef);
          el.preparedLimitText.textContent = `Prepared limit: ${limit}`;
          el.spellsPrepareBtn.style.display = "";
        }
      }

      function countPrepared() {
        let n = 0;
        for (const k in state.preparedSpells) if (state.preparedSpells[k]) n++;
        return n;
      }

      function getSpellDef(spellId) {
        if (!SPELLS) return null;
        if (SPELLS.spells && Array.isArray(SPELLS.spells)) {
          // support array schema
          for (const s of SPELLS.spells) if (s.id === spellId) return s;
        }
        if (SPELLS.spells && SPELLS.spells[spellId]) return SPELLS.spells[spellId];
        return null;
      }

      function splitHigherLevels(desc) {
        const d = String(desc || "");
        const idx = d.toLowerCase().indexOf("at higher levels");
        if (idx === -1) return { base: d.trim(), higher: "" };

        const base = d.slice(0, idx).trim();
        let higher = d.slice(idx).trim();
        higher = higher.replace(/^at higher levels\s*[:.\-]?\s*/i, "");
        return { base, higher };
      }

      function inferEconomyFromCastingTime(castingTime) {
        const t = String(castingTime || "").toLowerCase();
        if (t.includes("reaction")) return "reaction";
        if (t.includes("bonus")) return "bonus";
        return "action";
      }

      function getClassSpellList(classDef) {
        // spellcasting_rebuilt.json schema: spellListByLevel: { "0": [{id,name}], "1": ... }
        const out = [];
        if (!classDef || !classDef.spellListByLevel) return out;

        const keys = Object.keys(classDef.spellListByLevel).map(k => Number(k)).filter(n => Number.isFinite(n));
        keys.sort((a,b)=>a-b);

        for (const k of keys) {
          const arr = classDef.spellListByLevel[String(k)];
          if (!Array.isArray(arr)) continue;
          for (const item of arr) {
            if (item && item.id) out.push(item.id);
          }
        }

        const seen = new Set();
        const ordered = [];
        for (const id of out) {
          if (!id || seen.has(id)) continue;
          seen.add(id);
          ordered.push(id);
        }
        return ordered;
      }

      function getAlwaysAvailableIds(classDef) {
        // For this schema we treat cantrips as always available (level 0 list)
        if (!classDef || !classDef.spellListByLevel) return [];
        const arr = classDef.spellListByLevel["0"];
        if (!Array.isArray(arr)) return [];
        return arr.map(x => x.id).filter(Boolean);
      }

      async function openSpellbook(mode) {
        const classDef = getSelectedClassDef();
        if (!classDef) {
          setStatus("Select a class first to open the spellbook.", "error");
          return;
        }

        const ok = await loadSpellsIfNeeded();
        if (!ok) return;

        setSpellbookStatus("");
        el.spellbookTitle.textContent = `Spellbook (${state.classKey})`;

        await renderSpellbookList(mode || "view");

        if (typeof el.spellbookDialog.showModal === "function") el.spellbookDialog.showModal();
        else alert("Spellbook dialog not supported in this browser.");
      }

      async function renderSpellbookList(mode) {
        const classDef = getSelectedClassDef();
        if (!classDef || !SPELLS) return;

        const q = String(el.spellSearch.value || "").trim().toLowerCase();
        const levelFilter = String(el.spellLevelFilter.value || "all");

        const isPrep = isPreparedCaster(classDef);
        const limit = computePreparedLimit(classDef);
        const preparedNow = countPrepared();

        el.spellbookMainTitle.textContent = isPrep && mode === "prepare"
          ? `Prepare Spells (${preparedNow}/${limit})`
          : "Spells";

        el.spellbookList.innerHTML = "";
        el.spellbookAlwaysList.innerHTML = "";

        const mainIds = getClassSpellList(classDef);
        const alwaysIds = getAlwaysAvailableIds(classDef);

        function passFilter(id) {
          const d = getSpellDef(id);
          if (!d) return false;

          if (q) {
            const nm = String(d.name || id).toLowerCase();
            if (!nm.includes(q)) return false;
          }

          if (levelFilter !== "all") {
            const want = Number(levelFilter);
            if (Number.isFinite(want)) {
              const lv = Number.isFinite(Number(d.level)) ? Number(d.level) : -999;
              if (lv !== want) return false;
            }
          }

          return true;
        }

        function renderSpellButton(container, id, opts) {
          const d = getSpellDef(id);
          if (!d) return;

          const b = document.createElement("button");
          b.className = "btn";
          b.type = "button";

          const lv = Number.isFinite(Number(d.level)) ? Number(d.level) : 0;
          const prefix = (lv === 0) ? "[C] " : `[${lv}] `;
          const preparedMark = (opts && opts.showPrepared && state.preparedSpells[id]) ? " (Prepared)" : "";

          b.textContent = prefix + (d.name || id) + preparedMark;

          b.addEventListener("click", async () => {
            if (opts && opts.togglePrepare) {
              if (!isPrep) return;

              const now = !!state.preparedSpells[id];
              if (!now) {
                // Cantrips never count toward prepared limit
                if (lv !== 0) {
                  const cur = countPrepared();
                  if (cur >= limit) {
                    setSpellbookStatus(`Prepared limit reached (${limit}). Unprepare something first.`, "error");
                    return;
                  }
                }
              }

              // If cantrip, we allow toggle but it won't count anyway because countPrepared ignores cantrips later
              state.preparedSpells[id] = !now;
              saveState(state);
              await render();
              await renderSpellbookList(mode);
              return;
            }

            const meta = [
              (lv === 0 ? "Cantrip" : `Level ${lv}`),
              d.school ? d.school : "",
              d.ritual ? "Ritual" : "",
              d.concentration ? "Concentration" : "",
              d.castingTime ? `Casting: ${d.castingTime}` : ""
            ].filter(Boolean).join(" | ");

            const split = splitHigherLevels(d.description || d.text || "");
            const body = split.higher ? (split.base + "\n\nAt Higher Levels: " + split.higher) : split.base;

            openDialog(d.name || id, body || "(No rules text found.)", meta);
          });

          container.appendChild(b);

          const qbtn = document.createElement("button");
          qbtn.className = "qBtn";
          qbtn.type = "button";
          qbtn.textContent = "?";
          qbtn.addEventListener("click", () => {
            const lv2 = Number.isFinite(Number(d.level)) ? Number(d.level) : 0;
            const meta2 = [
              (lv2 === 0 ? "Cantrip" : `Level ${lv2}`),
              d.school ? d.school : "",
              d.ritual ? "Ritual" : "",
              d.concentration ? "Concentration" : "",
              d.castingTime ? `Casting: ${d.castingTime}` : ""
            ].filter(Boolean).join(" | ");

            const split = splitHigherLevels(d.description || d.text || "");
            const body = split.higher ? (split.base + "\n\nAt Higher Levels: " + split.higher) : split.base;

            openDialog(d.name || id, body || "(No rules text found.)", meta2);
          });
          container.appendChild(qbtn);
        }

        // Main list
        for (const id of mainIds) {
          if (!passFilter(id)) continue;
          renderSpellButton(el.spellbookList, id, { togglePrepare: (mode === "prepare"), showPrepared: true });
        }

        // Cantrips
        for (const id of alwaysIds) {
          if (!passFilter(id)) continue;
          renderSpellButton(el.spellbookAlwaysList, id, { togglePrepare: false, showPrepared: false });
        }

        if (mode === "prepare" && isPrep) {
          setSpellbookStatus(`Preparing: ${countPrepared()}/${limit}`, "ok");
        } else {
          setSpellbookStatus("");
        }
      }

      function getAvailableSlotLevelsForSpell(spellLevel) {
        const classDef = getSelectedClassDef();
        const slots = getSlotsForCurrent();
        const out = [];

        if (slots.type === "pact") {
          // Warlock can cast spells using pact slots, must be <= slotLevel (and spell must be <= that)
          if (spellLevel === 0) return ["cantrip"];
          if (spellLevel <= slots.slotLevel && slots.slots > getUsedSlots("pact")) {
            out.push(String(slots.slotLevel));
          }
          return out;
        }

        if (slots.type === "standard") {
          if (spellLevel === 0) return ["cantrip"];
          for (let i = spellLevel; i <= slots.levels.length; i++) {
            const max = slots.levels[i-1] || 0;
            if (max <= 0) continue;
            const used = getUsedSlots(String(i));
            if (used < max) out.push(String(i));
          }
          return out;
        }

        return out;
      }

      function countPreparedIgnoringCantrips() {
        const classDef = getSelectedClassDef();
        if (!classDef) return 0;
        let n = 0;
        for (const k in state.preparedSpells) {
          if (!state.preparedSpells[k]) continue;
          const d = SPELLS ? getSpellDef(k) : null;
          const lv = d && Number.isFinite(Number(d.level)) ? Number(d.level) : 0;
          if (lv === 0) continue;
          n++;
        }
        return n;
      }

      function renderPreparedSpellsArea() {
        el.preparedSpellsGrid.innerHTML = "";

        const classDef = getSelectedClassDef();
        if (!classDef) {
          const sp = document.createElement("div");
          sp.className = "sub";
          sp.textContent = "Select a class to use spellcasting.";
          el.preparedSpellsGrid.appendChild(sp);
          return;
        }

        const isPrep = isPreparedCaster(classDef);

        if (!isPrep) {
          const sp = document.createElement("div");
          sp.className = "sub";
          sp.textContent = "This class does not prepare spells. Use the Spellbook to reference spells, and use spell slots above.";
          el.preparedSpellsGrid.appendChild(sp);
          return;
        }

        if (!SPELLS) {
          const sp = document.createElement("div");
          sp.className = "sub";
          sp.textContent = "Load spells by opening the Spellbook once.";
          el.preparedSpellsGrid.appendChild(sp);
          return;
        }

        const preparedIds = Object.keys(state.preparedSpells).filter(id => state.preparedSpells[id]);
        if (preparedIds.length === 0) {
          const sp = document.createElement("div");
          sp.className = "sub";
          sp.textContent = "No prepared spells yet. Use “Prepare Spells”.";
          el.preparedSpellsGrid.appendChild(sp);
          return;
        }

        // sort by spell level then name
        preparedIds.sort((a,b)=>{
          const da = getSpellDef(a), db = getSpellDef(b);
          const la = da && Number.isFinite(Number(da.level)) ? Number(da.level) : 0;
          const lb = db && Number.isFinite(Number(db.level)) ? Number(db.level) : 0;
          if (la !== lb) return la - lb;
          return String(da?.name || a).localeCompare(String(db?.name || b));
        });

        for (const id of preparedIds) {
          const d = getSpellDef(id);
          if (!d) continue;

          const lv = Number.isFinite(Number(d.level)) ? Number(d.level) : 0;
          if (lv === 0) continue; // show cantrips in spellbook-only section

          const card = document.createElement("div");
          card.className = "spellCard";

          const left = document.createElement("div");
          const nm = document.createElement("div");
          nm.className = "spellName";
          nm.textContent = d.name || id;

          const meta = document.createElement("div");
          meta.className = "spellMeta";
          meta.textContent = `${lv === 0 ? "Cantrip" : "Level " + lv} | ${d.school || ""}`.trim();

          left.appendChild(nm);
          left.appendChild(meta);

          const right = document.createElement("div");
          right.className = "spellBtns";

          const castBtn = document.createElement("button");
          castBtn.className = "btn";
          castBtn.type = "button";
          castBtn.textContent = "Cast";
          castBtn.addEventListener("click", () => openCastDialog(id));
          right.appendChild(castBtn);

          const infoBtn = document.createElement("button");
          infoBtn.className = "qBtn";
          infoBtn.type = "button";
          infoBtn.textContent = "?";
          infoBtn.addEventListener("click", () => {
            const split = splitHigherLevels(d.description || d.text || "");
            const body = split.higher ? (split.base + "\n\nAt Higher Levels: " + split.higher) : split.base;
            openDialog(d.name || id, body || "(No rules text found.)", `${lv === 0 ? "Cantrip" : "Level " + lv} | ${d.school || ""}`);
          });
          right.appendChild(infoBtn);

          card.appendChild(left);
          card.appendChild(right);

          el.preparedSpellsGrid.appendChild(card);
        }
      }

      async function openCastDialog(spellId) {
        const ok = await loadSpellsIfNeeded();
        if (!ok) return;

        const d = getSpellDef(spellId);
        if (!d) {
          setSpellStatus("Spell not found in spells.json", "error");
          return;
        }

        currentCastSpellId = spellId;
        setCastStatus("");

        el.castTitle.textContent = `Cast: ${d.name || spellId}`;

        const lv = Number.isFinite(Number(d.level)) ? Number(d.level) : 0;
        const avail = getAvailableSlotLevelsForSpell(lv);

        el.castSlotLevel.innerHTML = "";
        if (lv === 0) {
          const o = document.createElement("option");
          o.value = "cantrip";
          o.textContent = "Cantrip (no slot)";
          el.castSlotLevel.appendChild(o);
        } else {
          if (avail.length === 0) {
            const o = document.createElement("option");
            o.value = "";
            o.textContent = "No slots available";
            el.castSlotLevel.appendChild(o);
          } else {
            for (const s of avail) {
              const o = document.createElement("option");
              o.value = s;
              o.textContent = `Level ${s}`;
              el.castSlotLevel.appendChild(o);
            }
          }
        }

        const split = splitHigherLevels(d.description || d.text || "");
        el.castBaseText.textContent = split.base || "";
        el.castHigherText.textContent = split.higher || "(No higher-level effect listed.)";

        // Default economy from casting time
        const econ = inferEconomyFromCastingTime(d.castingTime || d.casting_time || "");
        el.castEconomy.value = econ;

        if (typeof el.castDialog.showModal === "function") el.castDialog.showModal();
        else alert("Cast dialog not supported in this browser.");
      }

      async function confirmCast() {
        if (!currentCastSpellId) return;

        const ok = await loadSpellsIfNeeded();
        if (!ok) return;

        const d = getSpellDef(currentCastSpellId);
        if (!d) return;

        const lv = Number.isFinite(Number(d.level)) ? Number(d.level) : 0;
        const chosen = String(el.castSlotLevel.value || "");
        const econ = String(el.castEconomy.value || "action");

        // Action economy spend
        if (econ !== "none") {
          const spent = consumeEconomy(econ);
          if (!spent) {
            setCastStatus(`${actionTypeLabel(econ)} already used this turn.`, "error");
            await render();
            return;
          }
        }

        // Slot spend
        if (lv > 0) {
          if (!chosen) {
            setCastStatus("No slot available to cast this spell.", "error");
            await render();
            return;
          }

          const classDef = getSelectedClassDef();
          const slots = getSlotsForCurrent();

          if (slots.type === "pact") {
            const max = slots.slots;
            const used = clamp(getUsedSlots("pact"), 0, max);
            if (used >= max) {
              setCastStatus("No pact slots remaining.", "error");
              await render();
              return;
            }
            setUsedSlots("pact", used + 1);
          } else {
            const levelKey = chosen;
            const idx = Number(levelKey) - 1;
            const max = (slots.type === "standard" && idx >= 0 && idx < slots.levels.length) ? slots.levels[idx] : 0;
            const used = clamp(getUsedSlots(levelKey), 0, max);
            if (used >= max) {
              setCastStatus(`No level ${levelKey} slots remaining.`, "error");
              await render();
              return;
            }
            setUsedSlots(levelKey, used + 1);
          }
        }

        saveState(state);
        await render();
        setCastStatus("Spell cast. Slots and action economy updated.", "ok");
      }

      /* ---------- Main render ---------- */
      async function render() {
        normalize();
        renderCoreStats();
        renderCombat();
        updateEconomyIcons();
        renderEconomyButtons();
        renderAbilities();
        renderCalculator();
        setCalcResultFromExpr();

        rebuildClassSelect();
        renderSpellModInput();
        renderSpellSlots();
        renderPreparedSpellsArea();
      }

      function init() {
        el.levelInput = document.getElementById("levelInput");
        el.classSelect = document.getElementById("classSelect");

        el.spellModRow = document.getElementById("spellModRow");
        el.spellModLabel = document.getElementById("spellModLabel");
        el.spellModInput = document.getElementById("spellModInput");

        el.statAText = document.getElementById("statAText");
        el.statBText = document.getElementById("statBText");
        el.statCText = document.getElementById("statCText");

        el.shortRest = document.getElementById("shortRest");
        el.longRest = document.getElementById("longRest");
        el.nextTurn = document.getElementById("nextTurn");
        el.openCalcTop = document.getElementById("openCalcTop");
        el.openSpellbookTop = document.getElementById("openSpellbookTop");

        el.spellSlotsWrap = document.getElementById("spellSlotsWrap");
        el.spellMetaText = document.getElementById("spellMetaText");
        el.spellStatus = document.getElementById("spellStatus");
        el.spellsResetSlots = document.getElementById("spellsResetSlots");
        el.spellsPrepareBtn = document.getElementById("spellsPrepareBtn");
        el.preparedLimitText = document.getElementById("preparedLimitText");
        el.preparedSpellsGrid = document.getElementById("preparedSpellsGrid");

        el.iconAction = document.getElementById("iconAction");
        el.iconBonus = document.getElementById("iconBonus");
        el.iconReaction = document.getElementById("iconReaction");

        el.basicAttack = document.getElementById("basicAttack");
        el.actionOptions = document.getElementById("actionOptions");
        el.offhandAttack = document.getElementById("offhandAttack");
        el.bonusOptions = document.getElementById("bonusOptions");
        el.oppAttack = document.getElementById("oppAttack");
        el.readiedAttack = document.getElementById("readiedAttack");
        el.readiedInfo = document.getElementById("readiedInfo");
        el.reactionOptions = document.getElementById("reactionOptions");

        el.statusBar = document.getElementById("statusBar");

        el.hpNowText = document.getElementById("hpNowText");
        el.hpMaxText = document.getElementById("hpMaxText");
        el.hpTempText = document.getElementById("hpTempText");
        el.acText = document.getElementById("acText");
        el.hpMaxInput = document.getElementById("hpMaxInput");
        el.hpTempInput = document.getElementById("hpTempInput");
        el.acInput = document.getElementById("acInput");
        el.hpFull = document.getElementById("hpFull");
        el.hpZeroTemp = document.getElementById("hpZeroTemp");
        el.openCalc = document.getElementById("openCalc");

        el.abilitiesGrid = document.getElementById("abilitiesGrid");
        el.passivesGrid = document.getElementById("passivesGrid");

        el.infoDialog = document.getElementById("infoDialog");
        el.dlgTitle = document.getElementById("dlgTitle");
        el.dlgDesc = document.getElementById("dlgDesc");
        el.dlgMeta = document.getElementById("dlgMeta");
        el.dlgClose = document.getElementById("dlgClose");
        el.dlgX = document.getElementById("dlgX");

        el.optionsDialog = document.getElementById("optionsDialog");
        el.optTitle = document.getElementById("optTitle");
        el.optGenericBtns = document.getElementById("optGenericBtns");
        el.optAbilityBtns = document.getElementById("optAbilityBtns");
        el.optPassiveBtns = document.getElementById("optPassiveBtns");
        el.optStatus = document.getElementById("optStatus");
        el.optClose = document.getElementById("optClose");
        el.optX = document.getElementById("optX");
        el.optSectionGeneric = document.getElementById("optSectionGeneric");
        el.optGenericTitle = document.getElementById("optGenericTitle");

        el.calcDialog = document.getElementById("calcDialog");
        el.calcExpr = document.getElementById("calcExpr");
        el.calcResult = document.getElementById("calcResult");
        el.calcStatus = document.getElementById("calcStatus");
        el.calcGrid = document.getElementById("calcGrid");
        el.applyAsDamage = document.getElementById("applyAsDamage");
        el.applyAsHeal = document.getElementById("applyAsHeal");
        el.calcCopy = document.getElementById("calcCopy");
        el.calcClose = document.getElementById("calcClose");
        el.calcX = document.getElementById("calcX");

        el.spellbookDialog = document.getElementById("spellbookDialog");
        el.spellbookTitle = document.getElementById("spellbookTitle");
        el.spellbookX = document.getElementById("spellbookX");
        el.spellbookClose = document.getElementById("spellbookClose");
        el.spellbookList = document.getElementById("spellbookList");
        el.spellbookAlwaysList = document.getElementById("spellbookAlwaysList");
        el.spellbookStatus = document.getElementById("spellbookStatus");
        el.spellSearch = document.getElementById("spellSearch");
        el.spellLevelFilter = document.getElementById("spellLevelFilter");
        el.spellbookMainTitle = document.getElementById("spellbookMainTitle");

        el.castDialog = document.getElementById("castDialog");
        el.castTitle = document.getElementById("castTitle");
        el.castSlotLevel = document.getElementById("castSlotLevel");
        el.castEconomy = document.getElementById("castEconomy");
        el.castBaseText = document.getElementById("castBaseText");
        el.castHigherText = document.getElementById("castHigherText");
        el.castStatus = document.getElementById("castStatus");
        el.castConfirm = document.getElementById("castConfirm");
        el.castClose = document.getElementById("castClose");
        el.castX = document.getElementById("castX");

        el.levelInput.value = String(state.level);

        el.levelInput.addEventListener("input", async () => {
          state.level = clamp(nint(el.levelInput.value, 1), 1, 20);
          saveState(state);
          setStatus("");
          await render();
        });

        el.classSelect.addEventListener("input", async () => {
          state.classKey = String(el.classSelect.value || "");
          saveState(state);
          setSpellStatus("");
          await render();
        });

        el.spellModInput.addEventListener("input", async () => {
          state.spellMod = nint(el.spellModInput.value, 0);
          saveState(state);
          await render();
        });

        el.shortRest.addEventListener("click", doShortRest);
        el.longRest.addEventListener("click", doLongRest);
        el.nextTurn.addEventListener("click", nextTurn);

        el.basicAttack.addEventListener("click", async () => {
          normalize();
          const ok = useActionAttack();
          if (!ok) {
            setStatus("No attacks remaining this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          const maxAttacks = getMaxAttacksPerTurn();
          setStatus(`Basic Attack used (${state.attacksUsed}/${maxAttacks}).`, "ok");
        });

        el.actionOptions.addEventListener("click", () => openOptions("action"));
        el.bonusOptions.addEventListener("click", () => openOptions("bonus"));
        el.reactionOptions.addEventListener("click", () => openOptions("reaction"));

        el.offhandAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("bonus")) {
            setStatus("Bonus action already used this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          setStatus("Offhand Attack used (bonus action).", "ok");
        });

        el.oppAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("reaction")) {
            setStatus("Reaction already used this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          setStatus("Attack of Opportunity used (reaction).", "ok");
        });

        el.readiedAttack.addEventListener("click", async () => {
          normalize();
          if (!consumeEconomy("reaction")) {
            setStatus("Reaction already used this turn.", "error");
            await render();
            return;
          }
          saveState(state);
          await render();
          setStatus("Readied Attack used (reaction).", "ok");
        });

        el.readiedInfo.addEventListener("click", () => openDialog("Readied Attack", READIED_TEXT, ""));

        el.hpMaxInput.value = String(state.hpMax);
        el.hpTempInput.value = String(state.hpTemp);
        el.acInput.value = String(state.acBase);

        el.hpMaxInput.addEventListener("input", async () => {
          state.hpMax = Math.max(0, nint(el.hpMaxInput.value, 0));
          state.hpNow = clamp(state.hpNow, 0, state.hpMax);
          saveState(state);
          await render();
        });

        el.hpTempInput.addEventListener("input", async () => {
          state.hpTemp = Math.max(0, nint(el.hpTempInput.value, 0));
          saveState(state);
          await render();
        });

        el.acInput.addEventListener("input", async () => {
          state.acBase = Math.max(0, nint(el.acInput.value, 10));
          saveState(state);
          await render();
        });

        el.hpFull.addEventListener("click", async () => {
          normalize();
          state.hpNow = state.hpMax;
          saveState(state);
          await render();
          setStatus("Healed to full.", "ok");
        });

        el.hpZeroTemp.addEventListener("click", async () => {
          normalize();
          state.hpTemp = 0;
          saveState(state);
          await render();
          setStatus("Temp HP cleared.", "ok");
        });

        el.dlgClose.addEventListener("click", () => el.infoDialog.close());
        el.dlgX.addEventListener("click", () => el.infoDialog.close());
        el.infoDialog.addEventListener("click", (e) => {
          const rect = el.infoDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.infoDialog.close();
        });

        el.optClose.addEventListener("click", () => el.optionsDialog.close());
        el.optX.addEventListener("click", () => el.optionsDialog.close());
        el.optionsDialog.addEventListener("click", (e) => {
          const rect = el.optionsDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.optionsDialog.close();
        });

        function openCalc() {
          if (typeof el.calcDialog.showModal === "function") el.calcDialog.showModal();
          else alert("Calculator dialog not supported in this browser.");
        }
        el.openCalc.addEventListener("click", openCalc);
        el.openCalcTop.addEventListener("click", openCalc);

        el.calcClose.addEventListener("click", () => el.calcDialog.close());
        el.calcX.addEventListener("click", () => el.calcDialog.close());
        el.calcDialog.addEventListener("click", (e) => {
          const rect = el.calcDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.calcDialog.close();
        });

        el.calcGrid.addEventListener("click", (e) => {
          const btn = e.target.closest("[data-k]");
          if (!btn) return;
          const k = String(btn.getAttribute("data-k") || "");
          if (!k) return;
          calcPress(k);
        });

        document.addEventListener("keydown", (e) => {
          if (!el.calcDialog.open) return;

          const k = e.key;
          const tag = (document.activeElement && document.activeElement.tagName) ? document.activeElement.tagName.toLowerCase() : "";
          if (tag === "input" || tag === "select" || tag === "textarea") return;

          if (k >= "0" && k <= "9") return calcPress(k);
          if (k === "+" || k === "-" || k === "*" || k === "/" || k === "." || k === "(" || k === ")") return calcPress(k);
          if (k === "Enter" || k === "=") { e.preventDefault(); return calcPress("="); }
          if (k === "Backspace") { e.preventDefault(); return calcPress("⌫"); }
          if (k === "Escape") { e.preventDefault(); return calcPress("C"); }
        });

        el.applyAsDamage.addEventListener("click", async () => {
          normalize();
          const r = getCalcNumericResult();
          if (!r.ok) { setCalcStatus(r.error, "error"); return; }
          const amt = Math.max(0, Number(r.value));
          const used = applyDamage(amt);
          saveState(state);
          await render();
          setCalcStatus(`Applied ${amt} damage (Temp used: ${used.usedTemp}, HP used: ${used.usedHp}).`, "ok");
        });

        el.applyAsHeal.addEventListener("click", async () => {
          normalize();
          const r = getCalcNumericResult();
          if (!r.ok) { setCalcStatus(r.error, "error"); return; }
          const amt = Math.max(0, Number(r.value));
          const healed = applyHeal(amt);
          saveState(state);
          await render();
          setCalcStatus(`Applied ${healed} healing (capped at Max HP).`, "ok");
        });

        el.calcCopy.addEventListener("click", async () => {
          try {
            await navigator.clipboard.writeText(String(el.calcResult.textContent || "0"));
            setCalcStatus("Result copied to clipboard.", "ok");
          } catch {
            setCalcStatus("Could not copy (browser blocked clipboard).", "error");
          }
        });

        el.spellsResetSlots.addEventListener("click", async () => {
          resetAllSlots();
          await render();
          setSpellStatus("Spell slots reset.", "ok");
        });

        el.spellsPrepareBtn.addEventListener("click", () => openSpellbook("prepare"));
        el.openSpellbookTop.addEventListener("click", () => openSpellbook("view"));

        el.spellbookClose.addEventListener("click", () => el.spellbookDialog.close());
        el.spellbookX.addEventListener("click", () => el.spellbookDialog.close());
        el.spellbookDialog.addEventListener("click", (e) => {
          const rect = el.spellbookDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.spellbookDialog.close();
        });

        el.spellSearch.addEventListener("input", () => {
          const classDef = getSelectedClassDef();
          const mode = classDef && isPreparedCaster(classDef) ? "prepare" : "view";
          renderSpellbookList(mode);
        });
        el.spellLevelFilter.addEventListener("input", () => {
          const classDef = getSelectedClassDef();
          const mode = classDef && isPreparedCaster(classDef) ? "prepare" : "view";
          renderSpellbookList(mode);
        });

        el.castClose.addEventListener("click", () => el.castDialog.close());
        el.castX.addEventListener("click", () => el.castDialog.close());
        el.castDialog.addEventListener("click", (e) => {
          const rect = el.castDialog.getBoundingClientRect();
          const inside =
            e.clientX >= rect.left && e.clientX <= rect.right &&
            e.clientY >= rect.top && e.clientY <= rect.bottom;
          if (!inside) el.castDialog.close();
        });
        el.castConfirm.addEventListener("click", confirmCast);

        (async () => {
          await loadSupportDoc();
          await loadSpellcasting();
          rebuildClassSelect();
          updateEconomyIcons();
          await render();
        })();
      }

      document.addEventListener("DOMContentLoaded", init);
    </script>
  </body>
</html>
